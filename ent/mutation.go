// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/davidroman0O/go-tempolite/ent/activity"
	"github.com/davidroman0O/go-tempolite/ent/activityexecution"
	"github.com/davidroman0O/go-tempolite/ent/predicate"
	"github.com/davidroman0O/go-tempolite/ent/run"
	"github.com/davidroman0O/go-tempolite/ent/saga"
	"github.com/davidroman0O/go-tempolite/ent/sagaexecution"
	"github.com/davidroman0O/go-tempolite/ent/sagastepexecution"
	"github.com/davidroman0O/go-tempolite/ent/schema"
	"github.com/davidroman0O/go-tempolite/ent/sideeffect"
	"github.com/davidroman0O/go-tempolite/ent/sideeffectexecution"
	"github.com/davidroman0O/go-tempolite/ent/signal"
	"github.com/davidroman0O/go-tempolite/ent/workflow"
	"github.com/davidroman0O/go-tempolite/ent/workflowexecution"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity            = "Activity"
	TypeActivityExecution   = "ActivityExecution"
	TypeRun                 = "Run"
	TypeSaga                = "Saga"
	TypeSagaExecution       = "SagaExecution"
	TypeSagaStepExecution   = "SagaStepExecution"
	TypeSideEffect          = "SideEffect"
	TypeSideEffectExecution = "SideEffectExecution"
	TypeSignal              = "Signal"
	TypeWorkflow            = "Workflow"
	TypeWorkflowExecution   = "WorkflowExecution"
)

// ActivityMutation represents an operation that mutates the Activity nodes in the graph.
type ActivityMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	identity            *string
	handler_name        *string
	input               *[]interface{}
	appendinput         []interface{}
	retry_policy        *schema.RetryPolicy
	timeout             *time.Time
	created_at          *time.Time
	clearedFields       map[string]struct{}
	executions          map[string]struct{}
	removedexecutions   map[string]struct{}
	clearedexecutions   bool
	workflow            *string
	clearedworkflow     bool
	sagas               map[string]struct{}
	removedsagas        map[string]struct{}
	clearedsagas        bool
	side_effects        map[string]struct{}
	removedside_effects map[string]struct{}
	clearedside_effects bool
	done                bool
	oldValue            func(context.Context) (*Activity, error)
	predicates          []predicate.Activity
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows management of the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for the Activity entity.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the ID field of the mutation.
func withActivityID(id string) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Activity entities.
func (m *ActivityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Activity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIdentity sets the "identity" field.
func (m *ActivityMutation) SetIdentity(s string) {
	m.identity = &s
}

// Identity returns the value of the "identity" field in the mutation.
func (m *ActivityMutation) Identity() (r string, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old "identity" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// ResetIdentity resets all changes to the "identity" field.
func (m *ActivityMutation) ResetIdentity() {
	m.identity = nil
}

// SetHandlerName sets the "handler_name" field.
func (m *ActivityMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *ActivityMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *ActivityMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetInput sets the "input" field.
func (m *ActivityMutation) SetInput(i []interface{}) {
	m.input = &i
	m.appendinput = nil
}

// Input returns the value of the "input" field in the mutation.
func (m *ActivityMutation) Input() (r []interface{}, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldInput(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// AppendInput adds i to the "input" field.
func (m *ActivityMutation) AppendInput(i []interface{}) {
	m.appendinput = append(m.appendinput, i...)
}

// AppendedInput returns the list of values that were appended to the "input" field in this mutation.
func (m *ActivityMutation) AppendedInput() ([]interface{}, bool) {
	if len(m.appendinput) == 0 {
		return nil, false
	}
	return m.appendinput, true
}

// ResetInput resets all changes to the "input" field.
func (m *ActivityMutation) ResetInput() {
	m.input = nil
	m.appendinput = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *ActivityMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *ActivityMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ClearRetryPolicy clears the value of the "retry_policy" field.
func (m *ActivityMutation) ClearRetryPolicy() {
	m.retry_policy = nil
	m.clearedFields[activity.FieldRetryPolicy] = struct{}{}
}

// RetryPolicyCleared returns if the "retry_policy" field was cleared in this mutation.
func (m *ActivityMutation) RetryPolicyCleared() bool {
	_, ok := m.clearedFields[activity.FieldRetryPolicy]
	return ok
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *ActivityMutation) ResetRetryPolicy() {
	m.retry_policy = nil
	delete(m.clearedFields, activity.FieldRetryPolicy)
}

// SetTimeout sets the "timeout" field.
func (m *ActivityMutation) SetTimeout(t time.Time) {
	m.timeout = &t
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ActivityMutation) Timeout() (r time.Time, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldTimeout(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ClearTimeout clears the value of the "timeout" field.
func (m *ActivityMutation) ClearTimeout() {
	m.timeout = nil
	m.clearedFields[activity.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *ActivityMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[activity.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ActivityMutation) ResetTimeout() {
	m.timeout = nil
	delete(m.clearedFields, activity.FieldTimeout)
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddExecutionIDs adds the "executions" edge to the ActivityExecution entity by ids.
func (m *ActivityMutation) AddExecutionIDs(ids ...string) {
	if m.executions == nil {
		m.executions = make(map[string]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the ActivityExecution entity.
func (m *ActivityMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the ActivityExecution entity was cleared.
func (m *ActivityMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the ActivityExecution entity by IDs.
func (m *ActivityMutation) RemoveExecutionIDs(ids ...string) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the ActivityExecution entity.
func (m *ActivityMutation) RemovedExecutionsIDs() (ids []string) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *ActivityMutation) ExecutionsIDs() (ids []string) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *ActivityMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *ActivityMutation) SetWorkflowID(id string) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *ActivityMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *ActivityMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *ActivityMutation) WorkflowID() (id string, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) WorkflowIDs() (ids []string) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *ActivityMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// AddSagaIDs adds the "sagas" edge to the Saga entity by ids.
func (m *ActivityMutation) AddSagaIDs(ids ...string) {
	if m.sagas == nil {
		m.sagas = make(map[string]struct{})
	}
	for i := range ids {
		m.sagas[ids[i]] = struct{}{}
	}
}

// ClearSagas clears the "sagas" edge to the Saga entity.
func (m *ActivityMutation) ClearSagas() {
	m.clearedsagas = true
}

// SagasCleared reports if the "sagas" edge to the Saga entity was cleared.
func (m *ActivityMutation) SagasCleared() bool {
	return m.clearedsagas
}

// RemoveSagaIDs removes the "sagas" edge to the Saga entity by IDs.
func (m *ActivityMutation) RemoveSagaIDs(ids ...string) {
	if m.removedsagas == nil {
		m.removedsagas = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sagas, ids[i])
		m.removedsagas[ids[i]] = struct{}{}
	}
}

// RemovedSagas returns the removed IDs of the "sagas" edge to the Saga entity.
func (m *ActivityMutation) RemovedSagasIDs() (ids []string) {
	for id := range m.removedsagas {
		ids = append(ids, id)
	}
	return
}

// SagasIDs returns the "sagas" edge IDs in the mutation.
func (m *ActivityMutation) SagasIDs() (ids []string) {
	for id := range m.sagas {
		ids = append(ids, id)
	}
	return
}

// ResetSagas resets all changes to the "sagas" edge.
func (m *ActivityMutation) ResetSagas() {
	m.sagas = nil
	m.clearedsagas = false
	m.removedsagas = nil
}

// AddSideEffectIDs adds the "side_effects" edge to the SideEffect entity by ids.
func (m *ActivityMutation) AddSideEffectIDs(ids ...string) {
	if m.side_effects == nil {
		m.side_effects = make(map[string]struct{})
	}
	for i := range ids {
		m.side_effects[ids[i]] = struct{}{}
	}
}

// ClearSideEffects clears the "side_effects" edge to the SideEffect entity.
func (m *ActivityMutation) ClearSideEffects() {
	m.clearedside_effects = true
}

// SideEffectsCleared reports if the "side_effects" edge to the SideEffect entity was cleared.
func (m *ActivityMutation) SideEffectsCleared() bool {
	return m.clearedside_effects
}

// RemoveSideEffectIDs removes the "side_effects" edge to the SideEffect entity by IDs.
func (m *ActivityMutation) RemoveSideEffectIDs(ids ...string) {
	if m.removedside_effects == nil {
		m.removedside_effects = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.side_effects, ids[i])
		m.removedside_effects[ids[i]] = struct{}{}
	}
}

// RemovedSideEffects returns the removed IDs of the "side_effects" edge to the SideEffect entity.
func (m *ActivityMutation) RemovedSideEffectsIDs() (ids []string) {
	for id := range m.removedside_effects {
		ids = append(ids, id)
	}
	return
}

// SideEffectsIDs returns the "side_effects" edge IDs in the mutation.
func (m *ActivityMutation) SideEffectsIDs() (ids []string) {
	for id := range m.side_effects {
		ids = append(ids, id)
	}
	return
}

// ResetSideEffects resets all changes to the "side_effects" edge.
func (m *ActivityMutation) ResetSideEffects() {
	m.side_effects = nil
	m.clearedside_effects = false
	m.removedside_effects = nil
}

// Where appends a list predicates to the ActivityMutation builder.
func (m *ActivityMutation) Where(ps ...predicate.Activity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Activity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.identity != nil {
		fields = append(fields, activity.FieldIdentity)
	}
	if m.handler_name != nil {
		fields = append(fields, activity.FieldHandlerName)
	}
	if m.input != nil {
		fields = append(fields, activity.FieldInput)
	}
	if m.retry_policy != nil {
		fields = append(fields, activity.FieldRetryPolicy)
	}
	if m.timeout != nil {
		fields = append(fields, activity.FieldTimeout)
	}
	if m.created_at != nil {
		fields = append(fields, activity.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldIdentity:
		return m.Identity()
	case activity.FieldHandlerName:
		return m.HandlerName()
	case activity.FieldInput:
		return m.Input()
	case activity.FieldRetryPolicy:
		return m.RetryPolicy()
	case activity.FieldTimeout:
		return m.Timeout()
	case activity.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldIdentity:
		return m.OldIdentity(ctx)
	case activity.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case activity.FieldInput:
		return m.OldInput(ctx)
	case activity.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case activity.FieldTimeout:
		return m.OldTimeout(ctx)
	case activity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	case activity.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case activity.FieldInput:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case activity.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case activity.FieldTimeout:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case activity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activity.FieldRetryPolicy) {
		fields = append(fields, activity.FieldRetryPolicy)
	}
	if m.FieldCleared(activity.FieldTimeout) {
		fields = append(fields, activity.FieldTimeout)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	switch name {
	case activity.FieldRetryPolicy:
		m.ClearRetryPolicy()
		return nil
	case activity.FieldTimeout:
		m.ClearTimeout()
		return nil
	}
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldIdentity:
		m.ResetIdentity()
		return nil
	case activity.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case activity.FieldInput:
		m.ResetInput()
		return nil
	case activity.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case activity.FieldTimeout:
		m.ResetTimeout()
		return nil
	case activity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.executions != nil {
		edges = append(edges, activity.EdgeExecutions)
	}
	if m.workflow != nil {
		edges = append(edges, activity.EdgeWorkflow)
	}
	if m.sagas != nil {
		edges = append(edges, activity.EdgeSagas)
	}
	if m.side_effects != nil {
		edges = append(edges, activity.EdgeSideEffects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case activity.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeSagas:
		ids := make([]ent.Value, 0, len(m.sagas))
		for id := range m.sagas {
			ids = append(ids, id)
		}
		return ids
	case activity.EdgeSideEffects:
		ids := make([]ent.Value, 0, len(m.side_effects))
		for id := range m.side_effects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedexecutions != nil {
		edges = append(edges, activity.EdgeExecutions)
	}
	if m.removedsagas != nil {
		edges = append(edges, activity.EdgeSagas)
	}
	if m.removedside_effects != nil {
		edges = append(edges, activity.EdgeSideEffects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case activity.EdgeSagas:
		ids := make([]ent.Value, 0, len(m.removedsagas))
		for id := range m.removedsagas {
			ids = append(ids, id)
		}
		return ids
	case activity.EdgeSideEffects:
		ids := make([]ent.Value, 0, len(m.removedside_effects))
		for id := range m.removedside_effects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedexecutions {
		edges = append(edges, activity.EdgeExecutions)
	}
	if m.clearedworkflow {
		edges = append(edges, activity.EdgeWorkflow)
	}
	if m.clearedsagas {
		edges = append(edges, activity.EdgeSagas)
	}
	if m.clearedside_effects {
		edges = append(edges, activity.EdgeSideEffects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case activity.EdgeExecutions:
		return m.clearedexecutions
	case activity.EdgeWorkflow:
		return m.clearedworkflow
	case activity.EdgeSagas:
		return m.clearedsagas
	case activity.EdgeSideEffects:
		return m.clearedside_effects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	switch name {
	case activity.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	switch name {
	case activity.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case activity.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case activity.EdgeSagas:
		m.ResetSagas()
		return nil
	case activity.EdgeSideEffects:
		m.ResetSideEffects()
		return nil
	}
	return fmt.Errorf("unknown Activity edge %s", name)
}

// ActivityExecutionMutation represents an operation that mutates the ActivityExecution nodes in the graph.
type ActivityExecutionMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	run_id                        *string
	status                        *activityexecution.Status
	attempt                       *int
	addattempt                    *int
	output                        *[]interface{}
	appendoutput                  []interface{}
	error                         *string
	started_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	activity                      *string
	clearedactivity               bool
	workflow_execution            *string
	clearedworkflow_execution     bool
	side_effect_executions        map[string]struct{}
	removedside_effect_executions map[string]struct{}
	clearedside_effect_executions bool
	done                          bool
	oldValue                      func(context.Context) (*ActivityExecution, error)
	predicates                    []predicate.ActivityExecution
}

var _ ent.Mutation = (*ActivityExecutionMutation)(nil)

// activityexecutionOption allows management of the mutation configuration using functional options.
type activityexecutionOption func(*ActivityExecutionMutation)

// newActivityExecutionMutation creates new mutation for the ActivityExecution entity.
func newActivityExecutionMutation(c config, op Op, opts ...activityexecutionOption) *ActivityExecutionMutation {
	m := &ActivityExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityExecutionID sets the ID field of the mutation.
func withActivityExecutionID(id string) activityexecutionOption {
	return func(m *ActivityExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityExecution
		)
		m.oldValue = func(ctx context.Context) (*ActivityExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityExecution sets the old ActivityExecution of the mutation.
func withActivityExecution(node *ActivityExecution) activityexecutionOption {
	return func(m *ActivityExecutionMutation) {
		m.oldValue = func(context.Context) (*ActivityExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActivityExecution entities.
func (m *ActivityExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *ActivityExecutionMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *ActivityExecutionMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *ActivityExecutionMutation) ResetRunID() {
	m.run_id = nil
}

// SetStatus sets the "status" field.
func (m *ActivityExecutionMutation) SetStatus(a activityexecution.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *ActivityExecutionMutation) Status() (r activityexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldStatus(ctx context.Context) (v activityexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ActivityExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetAttempt sets the "attempt" field.
func (m *ActivityExecutionMutation) SetAttempt(i int) {
	m.attempt = &i
	m.addattempt = nil
}

// Attempt returns the value of the "attempt" field in the mutation.
func (m *ActivityExecutionMutation) Attempt() (r int, exists bool) {
	v := m.attempt
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempt returns the old "attempt" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldAttempt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempt: %w", err)
	}
	return oldValue.Attempt, nil
}

// AddAttempt adds i to the "attempt" field.
func (m *ActivityExecutionMutation) AddAttempt(i int) {
	if m.addattempt != nil {
		*m.addattempt += i
	} else {
		m.addattempt = &i
	}
}

// AddedAttempt returns the value that was added to the "attempt" field in this mutation.
func (m *ActivityExecutionMutation) AddedAttempt() (r int, exists bool) {
	v := m.addattempt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempt resets all changes to the "attempt" field.
func (m *ActivityExecutionMutation) ResetAttempt() {
	m.attempt = nil
	m.addattempt = nil
}

// SetOutput sets the "output" field.
func (m *ActivityExecutionMutation) SetOutput(i []interface{}) {
	m.output = &i
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *ActivityExecutionMutation) Output() (r []interface{}, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldOutput(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds i to the "output" field.
func (m *ActivityExecutionMutation) AppendOutput(i []interface{}) {
	m.appendoutput = append(m.appendoutput, i...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *ActivityExecutionMutation) AppendedOutput() ([]interface{}, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *ActivityExecutionMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[activityexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *ActivityExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[activityexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *ActivityExecutionMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, activityexecution.FieldOutput)
}

// SetError sets the "error" field.
func (m *ActivityExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ActivityExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ActivityExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[activityexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ActivityExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[activityexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ActivityExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, activityexecution.FieldError)
}

// SetStartedAt sets the "started_at" field.
func (m *ActivityExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ActivityExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ActivityExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActivityExecution entity.
// If the ActivityExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetActivityID sets the "activity" edge to the Activity entity by id.
func (m *ActivityExecutionMutation) SetActivityID(id string) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *ActivityExecutionMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *ActivityExecutionMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *ActivityExecutionMutation) ActivityID() (id string, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *ActivityExecutionMutation) ActivityIDs() (ids []string) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *ActivityExecutionMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// SetWorkflowExecutionID sets the "workflow_execution" edge to the WorkflowExecution entity by id.
func (m *ActivityExecutionMutation) SetWorkflowExecutionID(id string) {
	m.workflow_execution = &id
}

// ClearWorkflowExecution clears the "workflow_execution" edge to the WorkflowExecution entity.
func (m *ActivityExecutionMutation) ClearWorkflowExecution() {
	m.clearedworkflow_execution = true
}

// WorkflowExecutionCleared reports if the "workflow_execution" edge to the WorkflowExecution entity was cleared.
func (m *ActivityExecutionMutation) WorkflowExecutionCleared() bool {
	return m.clearedworkflow_execution
}

// WorkflowExecutionID returns the "workflow_execution" edge ID in the mutation.
func (m *ActivityExecutionMutation) WorkflowExecutionID() (id string, exists bool) {
	if m.workflow_execution != nil {
		return *m.workflow_execution, true
	}
	return
}

// WorkflowExecutionIDs returns the "workflow_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowExecutionID instead. It exists only for internal usage by the builders.
func (m *ActivityExecutionMutation) WorkflowExecutionIDs() (ids []string) {
	if id := m.workflow_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowExecution resets all changes to the "workflow_execution" edge.
func (m *ActivityExecutionMutation) ResetWorkflowExecution() {
	m.workflow_execution = nil
	m.clearedworkflow_execution = false
}

// AddSideEffectExecutionIDs adds the "side_effect_executions" edge to the SideEffectExecution entity by ids.
func (m *ActivityExecutionMutation) AddSideEffectExecutionIDs(ids ...string) {
	if m.side_effect_executions == nil {
		m.side_effect_executions = make(map[string]struct{})
	}
	for i := range ids {
		m.side_effect_executions[ids[i]] = struct{}{}
	}
}

// ClearSideEffectExecutions clears the "side_effect_executions" edge to the SideEffectExecution entity.
func (m *ActivityExecutionMutation) ClearSideEffectExecutions() {
	m.clearedside_effect_executions = true
}

// SideEffectExecutionsCleared reports if the "side_effect_executions" edge to the SideEffectExecution entity was cleared.
func (m *ActivityExecutionMutation) SideEffectExecutionsCleared() bool {
	return m.clearedside_effect_executions
}

// RemoveSideEffectExecutionIDs removes the "side_effect_executions" edge to the SideEffectExecution entity by IDs.
func (m *ActivityExecutionMutation) RemoveSideEffectExecutionIDs(ids ...string) {
	if m.removedside_effect_executions == nil {
		m.removedside_effect_executions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.side_effect_executions, ids[i])
		m.removedside_effect_executions[ids[i]] = struct{}{}
	}
}

// RemovedSideEffectExecutions returns the removed IDs of the "side_effect_executions" edge to the SideEffectExecution entity.
func (m *ActivityExecutionMutation) RemovedSideEffectExecutionsIDs() (ids []string) {
	for id := range m.removedside_effect_executions {
		ids = append(ids, id)
	}
	return
}

// SideEffectExecutionsIDs returns the "side_effect_executions" edge IDs in the mutation.
func (m *ActivityExecutionMutation) SideEffectExecutionsIDs() (ids []string) {
	for id := range m.side_effect_executions {
		ids = append(ids, id)
	}
	return
}

// ResetSideEffectExecutions resets all changes to the "side_effect_executions" edge.
func (m *ActivityExecutionMutation) ResetSideEffectExecutions() {
	m.side_effect_executions = nil
	m.clearedside_effect_executions = false
	m.removedside_effect_executions = nil
}

// Where appends a list predicates to the ActivityExecutionMutation builder.
func (m *ActivityExecutionMutation) Where(ps ...predicate.ActivityExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityExecution).
func (m *ActivityExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityExecutionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.run_id != nil {
		fields = append(fields, activityexecution.FieldRunID)
	}
	if m.status != nil {
		fields = append(fields, activityexecution.FieldStatus)
	}
	if m.attempt != nil {
		fields = append(fields, activityexecution.FieldAttempt)
	}
	if m.output != nil {
		fields = append(fields, activityexecution.FieldOutput)
	}
	if m.error != nil {
		fields = append(fields, activityexecution.FieldError)
	}
	if m.started_at != nil {
		fields = append(fields, activityexecution.FieldStartedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activityexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activityexecution.FieldRunID:
		return m.RunID()
	case activityexecution.FieldStatus:
		return m.Status()
	case activityexecution.FieldAttempt:
		return m.Attempt()
	case activityexecution.FieldOutput:
		return m.Output()
	case activityexecution.FieldError:
		return m.Error()
	case activityexecution.FieldStartedAt:
		return m.StartedAt()
	case activityexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activityexecution.FieldRunID:
		return m.OldRunID(ctx)
	case activityexecution.FieldStatus:
		return m.OldStatus(ctx)
	case activityexecution.FieldAttempt:
		return m.OldAttempt(ctx)
	case activityexecution.FieldOutput:
		return m.OldOutput(ctx)
	case activityexecution.FieldError:
		return m.OldError(ctx)
	case activityexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case activityexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activityexecution.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case activityexecution.FieldStatus:
		v, ok := value.(activityexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case activityexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempt(v)
		return nil
	case activityexecution.FieldOutput:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case activityexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case activityexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case activityexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addattempt != nil {
		fields = append(fields, activityexecution.FieldAttempt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activityexecution.FieldAttempt:
		return m.AddedAttempt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activityexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activityexecution.FieldOutput) {
		fields = append(fields, activityexecution.FieldOutput)
	}
	if m.FieldCleared(activityexecution.FieldError) {
		fields = append(fields, activityexecution.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityExecutionMutation) ClearField(name string) error {
	switch name {
	case activityexecution.FieldOutput:
		m.ClearOutput()
		return nil
	case activityexecution.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityExecutionMutation) ResetField(name string) error {
	switch name {
	case activityexecution.FieldRunID:
		m.ResetRunID()
		return nil
	case activityexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case activityexecution.FieldAttempt:
		m.ResetAttempt()
		return nil
	case activityexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case activityexecution.FieldError:
		m.ResetError()
		return nil
	case activityexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case activityexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.activity != nil {
		edges = append(edges, activityexecution.EdgeActivity)
	}
	if m.workflow_execution != nil {
		edges = append(edges, activityexecution.EdgeWorkflowExecution)
	}
	if m.side_effect_executions != nil {
		edges = append(edges, activityexecution.EdgeSideEffectExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activityexecution.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	case activityexecution.EdgeWorkflowExecution:
		if id := m.workflow_execution; id != nil {
			return []ent.Value{*id}
		}
	case activityexecution.EdgeSideEffectExecutions:
		ids := make([]ent.Value, 0, len(m.side_effect_executions))
		for id := range m.side_effect_executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedside_effect_executions != nil {
		edges = append(edges, activityexecution.EdgeSideEffectExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityExecutionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activityexecution.EdgeSideEffectExecutions:
		ids := make([]ent.Value, 0, len(m.removedside_effect_executions))
		for id := range m.removedside_effect_executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedactivity {
		edges = append(edges, activityexecution.EdgeActivity)
	}
	if m.clearedworkflow_execution {
		edges = append(edges, activityexecution.EdgeWorkflowExecution)
	}
	if m.clearedside_effect_executions {
		edges = append(edges, activityexecution.EdgeSideEffectExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case activityexecution.EdgeActivity:
		return m.clearedactivity
	case activityexecution.EdgeWorkflowExecution:
		return m.clearedworkflow_execution
	case activityexecution.EdgeSideEffectExecutions:
		return m.clearedside_effect_executions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityExecutionMutation) ClearEdge(name string) error {
	switch name {
	case activityexecution.EdgeActivity:
		m.ClearActivity()
		return nil
	case activityexecution.EdgeWorkflowExecution:
		m.ClearWorkflowExecution()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityExecutionMutation) ResetEdge(name string) error {
	switch name {
	case activityexecution.EdgeActivity:
		m.ResetActivity()
		return nil
	case activityexecution.EdgeWorkflowExecution:
		m.ResetWorkflowExecution()
		return nil
	case activityexecution.EdgeSideEffectExecutions:
		m.ResetSideEffectExecutions()
		return nil
	}
	return fmt.Errorf("unknown ActivityExecution edge %s", name)
}

// RunMutation represents an operation that mutates the Run nodes in the graph.
type RunMutation struct {
	config
	op              Op
	typ             string
	id              *string
	run_id          *string
	_type           *run.Type
	created_at      *time.Time
	clearedFields   map[string]struct{}
	workflow        *string
	clearedworkflow bool
	activity        *string
	clearedactivity bool
	done            bool
	oldValue        func(context.Context) (*Run, error)
	predicates      []predicate.Run
}

var _ ent.Mutation = (*RunMutation)(nil)

// runOption allows management of the mutation configuration using functional options.
type runOption func(*RunMutation)

// newRunMutation creates new mutation for the Run entity.
func newRunMutation(c config, op Op, opts ...runOption) *RunMutation {
	m := &RunMutation{
		config:        c,
		op:            op,
		typ:           TypeRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRunID sets the ID field of the mutation.
func withRunID(id string) runOption {
	return func(m *RunMutation) {
		var (
			err   error
			once  sync.Once
			value *Run
		)
		m.oldValue = func(ctx context.Context) (*Run, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Run.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRun sets the old Run of the mutation.
func withRun(node *Run) runOption {
	return func(m *RunMutation) {
		m.oldValue = func(context.Context) (*Run, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Run entities.
func (m *RunMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RunMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RunMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Run.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *RunMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *RunMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *RunMutation) ResetRunID() {
	m.run_id = nil
}

// SetType sets the "type" field.
func (m *RunMutation) SetType(r run.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RunMutation) GetType() (r run.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldType(ctx context.Context) (v run.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RunMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Run entity.
// If the Run object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RunMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *RunMutation) SetWorkflowID(id string) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *RunMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *RunMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *RunMutation) WorkflowID() (id string, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *RunMutation) WorkflowIDs() (ids []string) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *RunMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetActivityID sets the "activity" edge to the Activity entity by id.
func (m *RunMutation) SetActivityID(id string) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *RunMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *RunMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *RunMutation) ActivityID() (id string, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *RunMutation) ActivityIDs() (ids []string) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *RunMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// Where appends a list predicates to the RunMutation builder.
func (m *RunMutation) Where(ps ...predicate.Run) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RunMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RunMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Run, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RunMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RunMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Run).
func (m *RunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RunMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.run_id != nil {
		fields = append(fields, run.FieldRunID)
	}
	if m._type != nil {
		fields = append(fields, run.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, run.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case run.FieldRunID:
		return m.RunID()
	case run.FieldType:
		return m.GetType()
	case run.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case run.FieldRunID:
		return m.OldRunID(ctx)
	case run.FieldType:
		return m.OldType(ctx)
	case run.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Run field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case run.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case run.FieldType:
		v, ok := value.(run.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case run.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Run field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RunMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RunMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RunMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Run numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RunMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RunMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Run nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RunMutation) ResetField(name string) error {
	switch name {
	case run.FieldRunID:
		m.ResetRunID()
		return nil
	case run.FieldType:
		m.ResetType()
		return nil
	case run.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Run field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RunMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workflow != nil {
		edges = append(edges, run.EdgeWorkflow)
	}
	if m.activity != nil {
		edges = append(edges, run.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case run.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case run.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RunMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkflow {
		edges = append(edges, run.EdgeWorkflow)
	}
	if m.clearedactivity {
		edges = append(edges, run.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RunMutation) EdgeCleared(name string) bool {
	switch name {
	case run.EdgeWorkflow:
		return m.clearedworkflow
	case run.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RunMutation) ClearEdge(name string) error {
	switch name {
	case run.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case run.EdgeActivity:
		m.ClearActivity()
		return nil
	}
	return fmt.Errorf("unknown Run unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RunMutation) ResetEdge(name string) error {
	switch name {
	case run.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case run.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown Run edge %s", name)
}

// SagaMutation represents an operation that mutates the Saga nodes in the graph.
type SagaMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	input             *[]interface{}
	appendinput       []interface{}
	retry_policy      *schema.RetryPolicy
	timeout           *time.Time
	created_at        *time.Time
	clearedFields     map[string]struct{}
	executions        map[string]struct{}
	removedexecutions map[string]struct{}
	clearedexecutions bool
	activity          *string
	clearedactivity   bool
	done              bool
	oldValue          func(context.Context) (*Saga, error)
	predicates        []predicate.Saga
}

var _ ent.Mutation = (*SagaMutation)(nil)

// sagaOption allows management of the mutation configuration using functional options.
type sagaOption func(*SagaMutation)

// newSagaMutation creates new mutation for the Saga entity.
func newSagaMutation(c config, op Op, opts ...sagaOption) *SagaMutation {
	m := &SagaMutation{
		config:        c,
		op:            op,
		typ:           TypeSaga,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaID sets the ID field of the mutation.
func withSagaID(id string) sagaOption {
	return func(m *SagaMutation) {
		var (
			err   error
			once  sync.Once
			value *Saga
		)
		m.oldValue = func(ctx context.Context) (*Saga, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Saga.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaga sets the old Saga of the mutation.
func withSaga(node *Saga) sagaOption {
	return func(m *SagaMutation) {
		m.oldValue = func(context.Context) (*Saga, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Saga entities.
func (m *SagaMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Saga.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SagaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SagaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SagaMutation) ResetName() {
	m.name = nil
}

// SetInput sets the "input" field.
func (m *SagaMutation) SetInput(i []interface{}) {
	m.input = &i
	m.appendinput = nil
}

// Input returns the value of the "input" field in the mutation.
func (m *SagaMutation) Input() (r []interface{}, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldInput(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// AppendInput adds i to the "input" field.
func (m *SagaMutation) AppendInput(i []interface{}) {
	m.appendinput = append(m.appendinput, i...)
}

// AppendedInput returns the list of values that were appended to the "input" field in this mutation.
func (m *SagaMutation) AppendedInput() ([]interface{}, bool) {
	if len(m.appendinput) == 0 {
		return nil, false
	}
	return m.appendinput, true
}

// ResetInput resets all changes to the "input" field.
func (m *SagaMutation) ResetInput() {
	m.input = nil
	m.appendinput = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *SagaMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *SagaMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ClearRetryPolicy clears the value of the "retry_policy" field.
func (m *SagaMutation) ClearRetryPolicy() {
	m.retry_policy = nil
	m.clearedFields[saga.FieldRetryPolicy] = struct{}{}
}

// RetryPolicyCleared returns if the "retry_policy" field was cleared in this mutation.
func (m *SagaMutation) RetryPolicyCleared() bool {
	_, ok := m.clearedFields[saga.FieldRetryPolicy]
	return ok
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *SagaMutation) ResetRetryPolicy() {
	m.retry_policy = nil
	delete(m.clearedFields, saga.FieldRetryPolicy)
}

// SetTimeout sets the "timeout" field.
func (m *SagaMutation) SetTimeout(t time.Time) {
	m.timeout = &t
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *SagaMutation) Timeout() (r time.Time, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldTimeout(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ClearTimeout clears the value of the "timeout" field.
func (m *SagaMutation) ClearTimeout() {
	m.timeout = nil
	m.clearedFields[saga.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *SagaMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[saga.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *SagaMutation) ResetTimeout() {
	m.timeout = nil
	delete(m.clearedFields, saga.FieldTimeout)
}

// SetCreatedAt sets the "created_at" field.
func (m *SagaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SagaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Saga entity.
// If the Saga object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SagaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddExecutionIDs adds the "executions" edge to the SagaExecution entity by ids.
func (m *SagaMutation) AddExecutionIDs(ids ...string) {
	if m.executions == nil {
		m.executions = make(map[string]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the SagaExecution entity.
func (m *SagaMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the SagaExecution entity was cleared.
func (m *SagaMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the SagaExecution entity by IDs.
func (m *SagaMutation) RemoveExecutionIDs(ids ...string) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the SagaExecution entity.
func (m *SagaMutation) RemovedExecutionsIDs() (ids []string) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *SagaMutation) ExecutionsIDs() (ids []string) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *SagaMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// SetActivityID sets the "activity" edge to the Activity entity by id.
func (m *SagaMutation) SetActivityID(id string) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *SagaMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *SagaMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *SagaMutation) ActivityID() (id string, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *SagaMutation) ActivityIDs() (ids []string) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *SagaMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// Where appends a list predicates to the SagaMutation builder.
func (m *SagaMutation) Where(ps ...predicate.Saga) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Saga, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Saga).
func (m *SagaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, saga.FieldName)
	}
	if m.input != nil {
		fields = append(fields, saga.FieldInput)
	}
	if m.retry_policy != nil {
		fields = append(fields, saga.FieldRetryPolicy)
	}
	if m.timeout != nil {
		fields = append(fields, saga.FieldTimeout)
	}
	if m.created_at != nil {
		fields = append(fields, saga.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saga.FieldName:
		return m.Name()
	case saga.FieldInput:
		return m.Input()
	case saga.FieldRetryPolicy:
		return m.RetryPolicy()
	case saga.FieldTimeout:
		return m.Timeout()
	case saga.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saga.FieldName:
		return m.OldName(ctx)
	case saga.FieldInput:
		return m.OldInput(ctx)
	case saga.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case saga.FieldTimeout:
		return m.OldTimeout(ctx)
	case saga.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Saga field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saga.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case saga.FieldInput:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case saga.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case saga.FieldTimeout:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case saga.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Saga field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Saga numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(saga.FieldRetryPolicy) {
		fields = append(fields, saga.FieldRetryPolicy)
	}
	if m.FieldCleared(saga.FieldTimeout) {
		fields = append(fields, saga.FieldTimeout)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaMutation) ClearField(name string) error {
	switch name {
	case saga.FieldRetryPolicy:
		m.ClearRetryPolicy()
		return nil
	case saga.FieldTimeout:
		m.ClearTimeout()
		return nil
	}
	return fmt.Errorf("unknown Saga nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaMutation) ResetField(name string) error {
	switch name {
	case saga.FieldName:
		m.ResetName()
		return nil
	case saga.FieldInput:
		m.ResetInput()
		return nil
	case saga.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case saga.FieldTimeout:
		m.ResetTimeout()
		return nil
	case saga.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Saga field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.executions != nil {
		edges = append(edges, saga.EdgeExecutions)
	}
	if m.activity != nil {
		edges = append(edges, saga.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saga.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case saga.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedexecutions != nil {
		edges = append(edges, saga.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case saga.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexecutions {
		edges = append(edges, saga.EdgeExecutions)
	}
	if m.clearedactivity {
		edges = append(edges, saga.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaMutation) EdgeCleared(name string) bool {
	switch name {
	case saga.EdgeExecutions:
		return m.clearedexecutions
	case saga.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaMutation) ClearEdge(name string) error {
	switch name {
	case saga.EdgeActivity:
		m.ClearActivity()
		return nil
	}
	return fmt.Errorf("unknown Saga unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaMutation) ResetEdge(name string) error {
	switch name {
	case saga.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case saga.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown Saga edge %s", name)
}

// SagaExecutionMutation represents an operation that mutates the SagaExecution nodes in the graph.
type SagaExecutionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	run_id        *string
	status        *sagaexecution.Status
	attempt       *int
	addattempt    *int
	output        *[]interface{}
	appendoutput  []interface{}
	started_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	saga          *string
	clearedsaga   bool
	steps         map[string]struct{}
	removedsteps  map[string]struct{}
	clearedsteps  bool
	done          bool
	oldValue      func(context.Context) (*SagaExecution, error)
	predicates    []predicate.SagaExecution
}

var _ ent.Mutation = (*SagaExecutionMutation)(nil)

// sagaexecutionOption allows management of the mutation configuration using functional options.
type sagaexecutionOption func(*SagaExecutionMutation)

// newSagaExecutionMutation creates new mutation for the SagaExecution entity.
func newSagaExecutionMutation(c config, op Op, opts ...sagaexecutionOption) *SagaExecutionMutation {
	m := &SagaExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaExecutionID sets the ID field of the mutation.
func withSagaExecutionID(id string) sagaexecutionOption {
	return func(m *SagaExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaExecution
		)
		m.oldValue = func(ctx context.Context) (*SagaExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaExecution sets the old SagaExecution of the mutation.
func withSagaExecution(node *SagaExecution) sagaexecutionOption {
	return func(m *SagaExecutionMutation) {
		m.oldValue = func(context.Context) (*SagaExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SagaExecution entities.
func (m *SagaExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *SagaExecutionMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *SagaExecutionMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *SagaExecutionMutation) ResetRunID() {
	m.run_id = nil
}

// SetStatus sets the "status" field.
func (m *SagaExecutionMutation) SetStatus(s sagaexecution.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SagaExecutionMutation) Status() (r sagaexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldStatus(ctx context.Context) (v sagaexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SagaExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetAttempt sets the "attempt" field.
func (m *SagaExecutionMutation) SetAttempt(i int) {
	m.attempt = &i
	m.addattempt = nil
}

// Attempt returns the value of the "attempt" field in the mutation.
func (m *SagaExecutionMutation) Attempt() (r int, exists bool) {
	v := m.attempt
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempt returns the old "attempt" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldAttempt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempt: %w", err)
	}
	return oldValue.Attempt, nil
}

// AddAttempt adds i to the "attempt" field.
func (m *SagaExecutionMutation) AddAttempt(i int) {
	if m.addattempt != nil {
		*m.addattempt += i
	} else {
		m.addattempt = &i
	}
}

// AddedAttempt returns the value that was added to the "attempt" field in this mutation.
func (m *SagaExecutionMutation) AddedAttempt() (r int, exists bool) {
	v := m.addattempt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempt resets all changes to the "attempt" field.
func (m *SagaExecutionMutation) ResetAttempt() {
	m.attempt = nil
	m.addattempt = nil
}

// SetOutput sets the "output" field.
func (m *SagaExecutionMutation) SetOutput(i []interface{}) {
	m.output = &i
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *SagaExecutionMutation) Output() (r []interface{}, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldOutput(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds i to the "output" field.
func (m *SagaExecutionMutation) AppendOutput(i []interface{}) {
	m.appendoutput = append(m.appendoutput, i...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *SagaExecutionMutation) AppendedOutput() ([]interface{}, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *SagaExecutionMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[sagaexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *SagaExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[sagaexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *SagaExecutionMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, sagaexecution.FieldOutput)
}

// SetStartedAt sets the "started_at" field.
func (m *SagaExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SagaExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SagaExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SagaExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SagaExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SagaExecution entity.
// If the SagaExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SagaExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSagaID sets the "saga" edge to the Saga entity by id.
func (m *SagaExecutionMutation) SetSagaID(id string) {
	m.saga = &id
}

// ClearSaga clears the "saga" edge to the Saga entity.
func (m *SagaExecutionMutation) ClearSaga() {
	m.clearedsaga = true
}

// SagaCleared reports if the "saga" edge to the Saga entity was cleared.
func (m *SagaExecutionMutation) SagaCleared() bool {
	return m.clearedsaga
}

// SagaID returns the "saga" edge ID in the mutation.
func (m *SagaExecutionMutation) SagaID() (id string, exists bool) {
	if m.saga != nil {
		return *m.saga, true
	}
	return
}

// SagaIDs returns the "saga" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SagaID instead. It exists only for internal usage by the builders.
func (m *SagaExecutionMutation) SagaIDs() (ids []string) {
	if id := m.saga; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSaga resets all changes to the "saga" edge.
func (m *SagaExecutionMutation) ResetSaga() {
	m.saga = nil
	m.clearedsaga = false
}

// AddStepIDs adds the "steps" edge to the SagaStepExecution entity by ids.
func (m *SagaExecutionMutation) AddStepIDs(ids ...string) {
	if m.steps == nil {
		m.steps = make(map[string]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the "steps" edge to the SagaStepExecution entity.
func (m *SagaExecutionMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared reports if the "steps" edge to the SagaStepExecution entity was cleared.
func (m *SagaExecutionMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the "steps" edge to the SagaStepExecution entity by IDs.
func (m *SagaExecutionMutation) RemoveStepIDs(ids ...string) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.steps, ids[i])
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed IDs of the "steps" edge to the SagaStepExecution entity.
func (m *SagaExecutionMutation) RemovedStepsIDs() (ids []string) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the "steps" edge IDs in the mutation.
func (m *SagaExecutionMutation) StepsIDs() (ids []string) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps resets all changes to the "steps" edge.
func (m *SagaExecutionMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// Where appends a list predicates to the SagaExecutionMutation builder.
func (m *SagaExecutionMutation) Where(ps ...predicate.SagaExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaExecution).
func (m *SagaExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaExecutionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.run_id != nil {
		fields = append(fields, sagaexecution.FieldRunID)
	}
	if m.status != nil {
		fields = append(fields, sagaexecution.FieldStatus)
	}
	if m.attempt != nil {
		fields = append(fields, sagaexecution.FieldAttempt)
	}
	if m.output != nil {
		fields = append(fields, sagaexecution.FieldOutput)
	}
	if m.started_at != nil {
		fields = append(fields, sagaexecution.FieldStartedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sagaexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagaexecution.FieldRunID:
		return m.RunID()
	case sagaexecution.FieldStatus:
		return m.Status()
	case sagaexecution.FieldAttempt:
		return m.Attempt()
	case sagaexecution.FieldOutput:
		return m.Output()
	case sagaexecution.FieldStartedAt:
		return m.StartedAt()
	case sagaexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagaexecution.FieldRunID:
		return m.OldRunID(ctx)
	case sagaexecution.FieldStatus:
		return m.OldStatus(ctx)
	case sagaexecution.FieldAttempt:
		return m.OldAttempt(ctx)
	case sagaexecution.FieldOutput:
		return m.OldOutput(ctx)
	case sagaexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case sagaexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SagaExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagaexecution.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case sagaexecution.FieldStatus:
		v, ok := value.(sagaexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sagaexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempt(v)
		return nil
	case sagaexecution.FieldOutput:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case sagaexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case sagaexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SagaExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addattempt != nil {
		fields = append(fields, sagaexecution.FieldAttempt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sagaexecution.FieldAttempt:
		return m.AddedAttempt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sagaexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown SagaExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sagaexecution.FieldOutput) {
		fields = append(fields, sagaexecution.FieldOutput)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaExecutionMutation) ClearField(name string) error {
	switch name {
	case sagaexecution.FieldOutput:
		m.ClearOutput()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaExecutionMutation) ResetField(name string) error {
	switch name {
	case sagaexecution.FieldRunID:
		m.ResetRunID()
		return nil
	case sagaexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case sagaexecution.FieldAttempt:
		m.ResetAttempt()
		return nil
	case sagaexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case sagaexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case sagaexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.saga != nil {
		edges = append(edges, sagaexecution.EdgeSaga)
	}
	if m.steps != nil {
		edges = append(edges, sagaexecution.EdgeSteps)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagaexecution.EdgeSaga:
		if id := m.saga; id != nil {
			return []ent.Value{*id}
		}
	case sagaexecution.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsteps != nil {
		edges = append(edges, sagaexecution.EdgeSteps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaExecutionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sagaexecution.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsaga {
		edges = append(edges, sagaexecution.EdgeSaga)
	}
	if m.clearedsteps {
		edges = append(edges, sagaexecution.EdgeSteps)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case sagaexecution.EdgeSaga:
		return m.clearedsaga
	case sagaexecution.EdgeSteps:
		return m.clearedsteps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaExecutionMutation) ClearEdge(name string) error {
	switch name {
	case sagaexecution.EdgeSaga:
		m.ClearSaga()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaExecutionMutation) ResetEdge(name string) error {
	switch name {
	case sagaexecution.EdgeSaga:
		m.ResetSaga()
		return nil
	case sagaexecution.EdgeSteps:
		m.ResetSteps()
		return nil
	}
	return fmt.Errorf("unknown SagaExecution edge %s", name)
}

// SagaStepExecutionMutation represents an operation that mutates the SagaStepExecution nodes in the graph.
type SagaStepExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	handler_name          *string
	step_type             *sagastepexecution.StepType
	status                *sagastepexecution.Status
	sequence              *int
	addsequence           *int
	attempt               *int
	addattempt            *int
	input                 *[]interface{}
	appendinput           []interface{}
	output                *[]interface{}
	appendoutput          []interface{}
	started_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	saga_execution        *string
	clearedsaga_execution bool
	done                  bool
	oldValue              func(context.Context) (*SagaStepExecution, error)
	predicates            []predicate.SagaStepExecution
}

var _ ent.Mutation = (*SagaStepExecutionMutation)(nil)

// sagastepexecutionOption allows management of the mutation configuration using functional options.
type sagastepexecutionOption func(*SagaStepExecutionMutation)

// newSagaStepExecutionMutation creates new mutation for the SagaStepExecution entity.
func newSagaStepExecutionMutation(c config, op Op, opts ...sagastepexecutionOption) *SagaStepExecutionMutation {
	m := &SagaStepExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSagaStepExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSagaStepExecutionID sets the ID field of the mutation.
func withSagaStepExecutionID(id string) sagastepexecutionOption {
	return func(m *SagaStepExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SagaStepExecution
		)
		m.oldValue = func(ctx context.Context) (*SagaStepExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SagaStepExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSagaStepExecution sets the old SagaStepExecution of the mutation.
func withSagaStepExecution(node *SagaStepExecution) sagastepexecutionOption {
	return func(m *SagaStepExecutionMutation) {
		m.oldValue = func(context.Context) (*SagaStepExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SagaStepExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SagaStepExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SagaStepExecution entities.
func (m *SagaStepExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SagaStepExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SagaStepExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SagaStepExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHandlerName sets the "handler_name" field.
func (m *SagaStepExecutionMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *SagaStepExecutionMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the SagaStepExecution entity.
// If the SagaStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaStepExecutionMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *SagaStepExecutionMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetStepType sets the "step_type" field.
func (m *SagaStepExecutionMutation) SetStepType(st sagastepexecution.StepType) {
	m.step_type = &st
}

// StepType returns the value of the "step_type" field in the mutation.
func (m *SagaStepExecutionMutation) StepType() (r sagastepexecution.StepType, exists bool) {
	v := m.step_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStepType returns the old "step_type" field's value of the SagaStepExecution entity.
// If the SagaStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaStepExecutionMutation) OldStepType(ctx context.Context) (v sagastepexecution.StepType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepType: %w", err)
	}
	return oldValue.StepType, nil
}

// ResetStepType resets all changes to the "step_type" field.
func (m *SagaStepExecutionMutation) ResetStepType() {
	m.step_type = nil
}

// SetStatus sets the "status" field.
func (m *SagaStepExecutionMutation) SetStatus(s sagastepexecution.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SagaStepExecutionMutation) Status() (r sagastepexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SagaStepExecution entity.
// If the SagaStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaStepExecutionMutation) OldStatus(ctx context.Context) (v sagastepexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SagaStepExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetSequence sets the "sequence" field.
func (m *SagaStepExecutionMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *SagaStepExecutionMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the SagaStepExecution entity.
// If the SagaStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaStepExecutionMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *SagaStepExecutionMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *SagaStepExecutionMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *SagaStepExecutionMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetAttempt sets the "attempt" field.
func (m *SagaStepExecutionMutation) SetAttempt(i int) {
	m.attempt = &i
	m.addattempt = nil
}

// Attempt returns the value of the "attempt" field in the mutation.
func (m *SagaStepExecutionMutation) Attempt() (r int, exists bool) {
	v := m.attempt
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempt returns the old "attempt" field's value of the SagaStepExecution entity.
// If the SagaStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaStepExecutionMutation) OldAttempt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempt: %w", err)
	}
	return oldValue.Attempt, nil
}

// AddAttempt adds i to the "attempt" field.
func (m *SagaStepExecutionMutation) AddAttempt(i int) {
	if m.addattempt != nil {
		*m.addattempt += i
	} else {
		m.addattempt = &i
	}
}

// AddedAttempt returns the value that was added to the "attempt" field in this mutation.
func (m *SagaStepExecutionMutation) AddedAttempt() (r int, exists bool) {
	v := m.addattempt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempt resets all changes to the "attempt" field.
func (m *SagaStepExecutionMutation) ResetAttempt() {
	m.attempt = nil
	m.addattempt = nil
}

// SetInput sets the "input" field.
func (m *SagaStepExecutionMutation) SetInput(i []interface{}) {
	m.input = &i
	m.appendinput = nil
}

// Input returns the value of the "input" field in the mutation.
func (m *SagaStepExecutionMutation) Input() (r []interface{}, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the SagaStepExecution entity.
// If the SagaStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaStepExecutionMutation) OldInput(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// AppendInput adds i to the "input" field.
func (m *SagaStepExecutionMutation) AppendInput(i []interface{}) {
	m.appendinput = append(m.appendinput, i...)
}

// AppendedInput returns the list of values that were appended to the "input" field in this mutation.
func (m *SagaStepExecutionMutation) AppendedInput() ([]interface{}, bool) {
	if len(m.appendinput) == 0 {
		return nil, false
	}
	return m.appendinput, true
}

// ResetInput resets all changes to the "input" field.
func (m *SagaStepExecutionMutation) ResetInput() {
	m.input = nil
	m.appendinput = nil
}

// SetOutput sets the "output" field.
func (m *SagaStepExecutionMutation) SetOutput(i []interface{}) {
	m.output = &i
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *SagaStepExecutionMutation) Output() (r []interface{}, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the SagaStepExecution entity.
// If the SagaStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaStepExecutionMutation) OldOutput(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds i to the "output" field.
func (m *SagaStepExecutionMutation) AppendOutput(i []interface{}) {
	m.appendoutput = append(m.appendoutput, i...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *SagaStepExecutionMutation) AppendedOutput() ([]interface{}, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *SagaStepExecutionMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[sagastepexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *SagaStepExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[sagastepexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *SagaStepExecutionMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, sagastepexecution.FieldOutput)
}

// SetStartedAt sets the "started_at" field.
func (m *SagaStepExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SagaStepExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SagaStepExecution entity.
// If the SagaStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaStepExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SagaStepExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SagaStepExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SagaStepExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SagaStepExecution entity.
// If the SagaStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SagaStepExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SagaStepExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSagaExecutionID sets the "saga_execution" edge to the SagaExecution entity by id.
func (m *SagaStepExecutionMutation) SetSagaExecutionID(id string) {
	m.saga_execution = &id
}

// ClearSagaExecution clears the "saga_execution" edge to the SagaExecution entity.
func (m *SagaStepExecutionMutation) ClearSagaExecution() {
	m.clearedsaga_execution = true
}

// SagaExecutionCleared reports if the "saga_execution" edge to the SagaExecution entity was cleared.
func (m *SagaStepExecutionMutation) SagaExecutionCleared() bool {
	return m.clearedsaga_execution
}

// SagaExecutionID returns the "saga_execution" edge ID in the mutation.
func (m *SagaStepExecutionMutation) SagaExecutionID() (id string, exists bool) {
	if m.saga_execution != nil {
		return *m.saga_execution, true
	}
	return
}

// SagaExecutionIDs returns the "saga_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SagaExecutionID instead. It exists only for internal usage by the builders.
func (m *SagaStepExecutionMutation) SagaExecutionIDs() (ids []string) {
	if id := m.saga_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSagaExecution resets all changes to the "saga_execution" edge.
func (m *SagaStepExecutionMutation) ResetSagaExecution() {
	m.saga_execution = nil
	m.clearedsaga_execution = false
}

// Where appends a list predicates to the SagaStepExecutionMutation builder.
func (m *SagaStepExecutionMutation) Where(ps ...predicate.SagaStepExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SagaStepExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SagaStepExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SagaStepExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SagaStepExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SagaStepExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SagaStepExecution).
func (m *SagaStepExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SagaStepExecutionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.handler_name != nil {
		fields = append(fields, sagastepexecution.FieldHandlerName)
	}
	if m.step_type != nil {
		fields = append(fields, sagastepexecution.FieldStepType)
	}
	if m.status != nil {
		fields = append(fields, sagastepexecution.FieldStatus)
	}
	if m.sequence != nil {
		fields = append(fields, sagastepexecution.FieldSequence)
	}
	if m.attempt != nil {
		fields = append(fields, sagastepexecution.FieldAttempt)
	}
	if m.input != nil {
		fields = append(fields, sagastepexecution.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, sagastepexecution.FieldOutput)
	}
	if m.started_at != nil {
		fields = append(fields, sagastepexecution.FieldStartedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sagastepexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SagaStepExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sagastepexecution.FieldHandlerName:
		return m.HandlerName()
	case sagastepexecution.FieldStepType:
		return m.StepType()
	case sagastepexecution.FieldStatus:
		return m.Status()
	case sagastepexecution.FieldSequence:
		return m.Sequence()
	case sagastepexecution.FieldAttempt:
		return m.Attempt()
	case sagastepexecution.FieldInput:
		return m.Input()
	case sagastepexecution.FieldOutput:
		return m.Output()
	case sagastepexecution.FieldStartedAt:
		return m.StartedAt()
	case sagastepexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SagaStepExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sagastepexecution.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case sagastepexecution.FieldStepType:
		return m.OldStepType(ctx)
	case sagastepexecution.FieldStatus:
		return m.OldStatus(ctx)
	case sagastepexecution.FieldSequence:
		return m.OldSequence(ctx)
	case sagastepexecution.FieldAttempt:
		return m.OldAttempt(ctx)
	case sagastepexecution.FieldInput:
		return m.OldInput(ctx)
	case sagastepexecution.FieldOutput:
		return m.OldOutput(ctx)
	case sagastepexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case sagastepexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SagaStepExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaStepExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sagastepexecution.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case sagastepexecution.FieldStepType:
		v, ok := value.(sagastepexecution.StepType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepType(v)
		return nil
	case sagastepexecution.FieldStatus:
		v, ok := value.(sagastepexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sagastepexecution.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case sagastepexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempt(v)
		return nil
	case sagastepexecution.FieldInput:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case sagastepexecution.FieldOutput:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case sagastepexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case sagastepexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SagaStepExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SagaStepExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, sagastepexecution.FieldSequence)
	}
	if m.addattempt != nil {
		fields = append(fields, sagastepexecution.FieldAttempt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SagaStepExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sagastepexecution.FieldSequence:
		return m.AddedSequence()
	case sagastepexecution.FieldAttempt:
		return m.AddedAttempt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SagaStepExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sagastepexecution.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	case sagastepexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown SagaStepExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SagaStepExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sagastepexecution.FieldOutput) {
		fields = append(fields, sagastepexecution.FieldOutput)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SagaStepExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SagaStepExecutionMutation) ClearField(name string) error {
	switch name {
	case sagastepexecution.FieldOutput:
		m.ClearOutput()
		return nil
	}
	return fmt.Errorf("unknown SagaStepExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SagaStepExecutionMutation) ResetField(name string) error {
	switch name {
	case sagastepexecution.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case sagastepexecution.FieldStepType:
		m.ResetStepType()
		return nil
	case sagastepexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case sagastepexecution.FieldSequence:
		m.ResetSequence()
		return nil
	case sagastepexecution.FieldAttempt:
		m.ResetAttempt()
		return nil
	case sagastepexecution.FieldInput:
		m.ResetInput()
		return nil
	case sagastepexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case sagastepexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case sagastepexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SagaStepExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SagaStepExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.saga_execution != nil {
		edges = append(edges, sagastepexecution.EdgeSagaExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SagaStepExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sagastepexecution.EdgeSagaExecution:
		if id := m.saga_execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SagaStepExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SagaStepExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SagaStepExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsaga_execution {
		edges = append(edges, sagastepexecution.EdgeSagaExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SagaStepExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case sagastepexecution.EdgeSagaExecution:
		return m.clearedsaga_execution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SagaStepExecutionMutation) ClearEdge(name string) error {
	switch name {
	case sagastepexecution.EdgeSagaExecution:
		m.ClearSagaExecution()
		return nil
	}
	return fmt.Errorf("unknown SagaStepExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SagaStepExecutionMutation) ResetEdge(name string) error {
	switch name {
	case sagastepexecution.EdgeSagaExecution:
		m.ResetSagaExecution()
		return nil
	}
	return fmt.Errorf("unknown SagaStepExecution edge %s", name)
}

// SideEffectMutation represents an operation that mutates the SideEffect nodes in the graph.
type SideEffectMutation struct {
	config
	op                Op
	typ               string
	id                *string
	identity          *string
	handler_name      *string
	input             *[]interface{}
	appendinput       []interface{}
	retry_policy      *schema.RetryPolicy
	timeout           *time.Time
	created_at        *time.Time
	clearedFields     map[string]struct{}
	executions        map[string]struct{}
	removedexecutions map[string]struct{}
	clearedexecutions bool
	activity          *string
	clearedactivity   bool
	done              bool
	oldValue          func(context.Context) (*SideEffect, error)
	predicates        []predicate.SideEffect
}

var _ ent.Mutation = (*SideEffectMutation)(nil)

// sideeffectOption allows management of the mutation configuration using functional options.
type sideeffectOption func(*SideEffectMutation)

// newSideEffectMutation creates new mutation for the SideEffect entity.
func newSideEffectMutation(c config, op Op, opts ...sideeffectOption) *SideEffectMutation {
	m := &SideEffectMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffect,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectID sets the ID field of the mutation.
func withSideEffectID(id string) sideeffectOption {
	return func(m *SideEffectMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffect
		)
		m.oldValue = func(ctx context.Context) (*SideEffect, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffect.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffect sets the old SideEffect of the mutation.
func withSideEffect(node *SideEffect) sideeffectOption {
	return func(m *SideEffectMutation) {
		m.oldValue = func(context.Context) (*SideEffect, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SideEffect entities.
func (m *SideEffectMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffect.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIdentity sets the "identity" field.
func (m *SideEffectMutation) SetIdentity(s string) {
	m.identity = &s
}

// Identity returns the value of the "identity" field in the mutation.
func (m *SideEffectMutation) Identity() (r string, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old "identity" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// ResetIdentity resets all changes to the "identity" field.
func (m *SideEffectMutation) ResetIdentity() {
	m.identity = nil
}

// SetHandlerName sets the "handler_name" field.
func (m *SideEffectMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *SideEffectMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *SideEffectMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetInput sets the "input" field.
func (m *SideEffectMutation) SetInput(i []interface{}) {
	m.input = &i
	m.appendinput = nil
}

// Input returns the value of the "input" field in the mutation.
func (m *SideEffectMutation) Input() (r []interface{}, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldInput(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// AppendInput adds i to the "input" field.
func (m *SideEffectMutation) AppendInput(i []interface{}) {
	m.appendinput = append(m.appendinput, i...)
}

// AppendedInput returns the list of values that were appended to the "input" field in this mutation.
func (m *SideEffectMutation) AppendedInput() ([]interface{}, bool) {
	if len(m.appendinput) == 0 {
		return nil, false
	}
	return m.appendinput, true
}

// ResetInput resets all changes to the "input" field.
func (m *SideEffectMutation) ResetInput() {
	m.input = nil
	m.appendinput = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *SideEffectMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *SideEffectMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ClearRetryPolicy clears the value of the "retry_policy" field.
func (m *SideEffectMutation) ClearRetryPolicy() {
	m.retry_policy = nil
	m.clearedFields[sideeffect.FieldRetryPolicy] = struct{}{}
}

// RetryPolicyCleared returns if the "retry_policy" field was cleared in this mutation.
func (m *SideEffectMutation) RetryPolicyCleared() bool {
	_, ok := m.clearedFields[sideeffect.FieldRetryPolicy]
	return ok
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *SideEffectMutation) ResetRetryPolicy() {
	m.retry_policy = nil
	delete(m.clearedFields, sideeffect.FieldRetryPolicy)
}

// SetTimeout sets the "timeout" field.
func (m *SideEffectMutation) SetTimeout(t time.Time) {
	m.timeout = &t
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *SideEffectMutation) Timeout() (r time.Time, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldTimeout(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ClearTimeout clears the value of the "timeout" field.
func (m *SideEffectMutation) ClearTimeout() {
	m.timeout = nil
	m.clearedFields[sideeffect.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *SideEffectMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[sideeffect.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *SideEffectMutation) ResetTimeout() {
	m.timeout = nil
	delete(m.clearedFields, sideeffect.FieldTimeout)
}

// SetCreatedAt sets the "created_at" field.
func (m *SideEffectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SideEffectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SideEffect entity.
// If the SideEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SideEffectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddExecutionIDs adds the "executions" edge to the SideEffectExecution entity by ids.
func (m *SideEffectMutation) AddExecutionIDs(ids ...string) {
	if m.executions == nil {
		m.executions = make(map[string]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the SideEffectExecution entity.
func (m *SideEffectMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the SideEffectExecution entity was cleared.
func (m *SideEffectMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the SideEffectExecution entity by IDs.
func (m *SideEffectMutation) RemoveExecutionIDs(ids ...string) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the SideEffectExecution entity.
func (m *SideEffectMutation) RemovedExecutionsIDs() (ids []string) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *SideEffectMutation) ExecutionsIDs() (ids []string) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *SideEffectMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// SetActivityID sets the "activity" edge to the Activity entity by id.
func (m *SideEffectMutation) SetActivityID(id string) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *SideEffectMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *SideEffectMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *SideEffectMutation) ActivityID() (id string, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *SideEffectMutation) ActivityIDs() (ids []string) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *SideEffectMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// Where appends a list predicates to the SideEffectMutation builder.
func (m *SideEffectMutation) Where(ps ...predicate.SideEffect) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffect, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffect).
func (m *SideEffectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.identity != nil {
		fields = append(fields, sideeffect.FieldIdentity)
	}
	if m.handler_name != nil {
		fields = append(fields, sideeffect.FieldHandlerName)
	}
	if m.input != nil {
		fields = append(fields, sideeffect.FieldInput)
	}
	if m.retry_policy != nil {
		fields = append(fields, sideeffect.FieldRetryPolicy)
	}
	if m.timeout != nil {
		fields = append(fields, sideeffect.FieldTimeout)
	}
	if m.created_at != nil {
		fields = append(fields, sideeffect.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sideeffect.FieldIdentity:
		return m.Identity()
	case sideeffect.FieldHandlerName:
		return m.HandlerName()
	case sideeffect.FieldInput:
		return m.Input()
	case sideeffect.FieldRetryPolicy:
		return m.RetryPolicy()
	case sideeffect.FieldTimeout:
		return m.Timeout()
	case sideeffect.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sideeffect.FieldIdentity:
		return m.OldIdentity(ctx)
	case sideeffect.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case sideeffect.FieldInput:
		return m.OldInput(ctx)
	case sideeffect.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case sideeffect.FieldTimeout:
		return m.OldTimeout(ctx)
	case sideeffect.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SideEffect field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sideeffect.FieldIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	case sideeffect.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case sideeffect.FieldInput:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case sideeffect.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case sideeffect.FieldTimeout:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case sideeffect.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffect field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SideEffect numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sideeffect.FieldRetryPolicy) {
		fields = append(fields, sideeffect.FieldRetryPolicy)
	}
	if m.FieldCleared(sideeffect.FieldTimeout) {
		fields = append(fields, sideeffect.FieldTimeout)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectMutation) ClearField(name string) error {
	switch name {
	case sideeffect.FieldRetryPolicy:
		m.ClearRetryPolicy()
		return nil
	case sideeffect.FieldTimeout:
		m.ClearTimeout()
		return nil
	}
	return fmt.Errorf("unknown SideEffect nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectMutation) ResetField(name string) error {
	switch name {
	case sideeffect.FieldIdentity:
		m.ResetIdentity()
		return nil
	case sideeffect.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case sideeffect.FieldInput:
		m.ResetInput()
		return nil
	case sideeffect.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case sideeffect.FieldTimeout:
		m.ResetTimeout()
		return nil
	case sideeffect.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SideEffect field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.executions != nil {
		edges = append(edges, sideeffect.EdgeExecutions)
	}
	if m.activity != nil {
		edges = append(edges, sideeffect.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffect.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case sideeffect.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedexecutions != nil {
		edges = append(edges, sideeffect.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sideeffect.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexecutions {
		edges = append(edges, sideeffect.EdgeExecutions)
	}
	if m.clearedactivity {
		edges = append(edges, sideeffect.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffect.EdgeExecutions:
		return m.clearedexecutions
	case sideeffect.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectMutation) ClearEdge(name string) error {
	switch name {
	case sideeffect.EdgeActivity:
		m.ClearActivity()
		return nil
	}
	return fmt.Errorf("unknown SideEffect unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectMutation) ResetEdge(name string) error {
	switch name {
	case sideeffect.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case sideeffect.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown SideEffect edge %s", name)
}

// SideEffectExecutionMutation represents an operation that mutates the SideEffectExecution nodes in the graph.
type SideEffectExecutionMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	run_id                    *string
	status                    *sideeffectexecution.Status
	attempt                   *int
	addattempt                *int
	output                    *[]interface{}
	appendoutput              []interface{}
	started_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	side_effect               *string
	clearedside_effect        bool
	activity_execution        *string
	clearedactivity_execution bool
	done                      bool
	oldValue                  func(context.Context) (*SideEffectExecution, error)
	predicates                []predicate.SideEffectExecution
}

var _ ent.Mutation = (*SideEffectExecutionMutation)(nil)

// sideeffectexecutionOption allows management of the mutation configuration using functional options.
type sideeffectexecutionOption func(*SideEffectExecutionMutation)

// newSideEffectExecutionMutation creates new mutation for the SideEffectExecution entity.
func newSideEffectExecutionMutation(c config, op Op, opts ...sideeffectexecutionOption) *SideEffectExecutionMutation {
	m := &SideEffectExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeSideEffectExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSideEffectExecutionID sets the ID field of the mutation.
func withSideEffectExecutionID(id string) sideeffectexecutionOption {
	return func(m *SideEffectExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *SideEffectExecution
		)
		m.oldValue = func(ctx context.Context) (*SideEffectExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SideEffectExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSideEffectExecution sets the old SideEffectExecution of the mutation.
func withSideEffectExecution(node *SideEffectExecution) sideeffectexecutionOption {
	return func(m *SideEffectExecutionMutation) {
		m.oldValue = func(context.Context) (*SideEffectExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SideEffectExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SideEffectExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SideEffectExecution entities.
func (m *SideEffectExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SideEffectExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SideEffectExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SideEffectExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *SideEffectExecutionMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *SideEffectExecutionMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *SideEffectExecutionMutation) ResetRunID() {
	m.run_id = nil
}

// SetStatus sets the "status" field.
func (m *SideEffectExecutionMutation) SetStatus(s sideeffectexecution.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SideEffectExecutionMutation) Status() (r sideeffectexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldStatus(ctx context.Context) (v sideeffectexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SideEffectExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetAttempt sets the "attempt" field.
func (m *SideEffectExecutionMutation) SetAttempt(i int) {
	m.attempt = &i
	m.addattempt = nil
}

// Attempt returns the value of the "attempt" field in the mutation.
func (m *SideEffectExecutionMutation) Attempt() (r int, exists bool) {
	v := m.attempt
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempt returns the old "attempt" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldAttempt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempt: %w", err)
	}
	return oldValue.Attempt, nil
}

// AddAttempt adds i to the "attempt" field.
func (m *SideEffectExecutionMutation) AddAttempt(i int) {
	if m.addattempt != nil {
		*m.addattempt += i
	} else {
		m.addattempt = &i
	}
}

// AddedAttempt returns the value that was added to the "attempt" field in this mutation.
func (m *SideEffectExecutionMutation) AddedAttempt() (r int, exists bool) {
	v := m.addattempt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempt resets all changes to the "attempt" field.
func (m *SideEffectExecutionMutation) ResetAttempt() {
	m.attempt = nil
	m.addattempt = nil
}

// SetOutput sets the "output" field.
func (m *SideEffectExecutionMutation) SetOutput(i []interface{}) {
	m.output = &i
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *SideEffectExecutionMutation) Output() (r []interface{}, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldOutput(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds i to the "output" field.
func (m *SideEffectExecutionMutation) AppendOutput(i []interface{}) {
	m.appendoutput = append(m.appendoutput, i...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *SideEffectExecutionMutation) AppendedOutput() ([]interface{}, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *SideEffectExecutionMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[sideeffectexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *SideEffectExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[sideeffectexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *SideEffectExecutionMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, sideeffectexecution.FieldOutput)
}

// SetStartedAt sets the "started_at" field.
func (m *SideEffectExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SideEffectExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SideEffectExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SideEffectExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SideEffectExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SideEffectExecution entity.
// If the SideEffectExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SideEffectExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SideEffectExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSideEffectID sets the "side_effect" edge to the SideEffect entity by id.
func (m *SideEffectExecutionMutation) SetSideEffectID(id string) {
	m.side_effect = &id
}

// ClearSideEffect clears the "side_effect" edge to the SideEffect entity.
func (m *SideEffectExecutionMutation) ClearSideEffect() {
	m.clearedside_effect = true
}

// SideEffectCleared reports if the "side_effect" edge to the SideEffect entity was cleared.
func (m *SideEffectExecutionMutation) SideEffectCleared() bool {
	return m.clearedside_effect
}

// SideEffectID returns the "side_effect" edge ID in the mutation.
func (m *SideEffectExecutionMutation) SideEffectID() (id string, exists bool) {
	if m.side_effect != nil {
		return *m.side_effect, true
	}
	return
}

// SideEffectIDs returns the "side_effect" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SideEffectID instead. It exists only for internal usage by the builders.
func (m *SideEffectExecutionMutation) SideEffectIDs() (ids []string) {
	if id := m.side_effect; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSideEffect resets all changes to the "side_effect" edge.
func (m *SideEffectExecutionMutation) ResetSideEffect() {
	m.side_effect = nil
	m.clearedside_effect = false
}

// SetActivityExecutionID sets the "activity_execution" edge to the ActivityExecution entity by id.
func (m *SideEffectExecutionMutation) SetActivityExecutionID(id string) {
	m.activity_execution = &id
}

// ClearActivityExecution clears the "activity_execution" edge to the ActivityExecution entity.
func (m *SideEffectExecutionMutation) ClearActivityExecution() {
	m.clearedactivity_execution = true
}

// ActivityExecutionCleared reports if the "activity_execution" edge to the ActivityExecution entity was cleared.
func (m *SideEffectExecutionMutation) ActivityExecutionCleared() bool {
	return m.clearedactivity_execution
}

// ActivityExecutionID returns the "activity_execution" edge ID in the mutation.
func (m *SideEffectExecutionMutation) ActivityExecutionID() (id string, exists bool) {
	if m.activity_execution != nil {
		return *m.activity_execution, true
	}
	return
}

// ActivityExecutionIDs returns the "activity_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityExecutionID instead. It exists only for internal usage by the builders.
func (m *SideEffectExecutionMutation) ActivityExecutionIDs() (ids []string) {
	if id := m.activity_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivityExecution resets all changes to the "activity_execution" edge.
func (m *SideEffectExecutionMutation) ResetActivityExecution() {
	m.activity_execution = nil
	m.clearedactivity_execution = false
}

// Where appends a list predicates to the SideEffectExecutionMutation builder.
func (m *SideEffectExecutionMutation) Where(ps ...predicate.SideEffectExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SideEffectExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SideEffectExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SideEffectExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SideEffectExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SideEffectExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SideEffectExecution).
func (m *SideEffectExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SideEffectExecutionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.run_id != nil {
		fields = append(fields, sideeffectexecution.FieldRunID)
	}
	if m.status != nil {
		fields = append(fields, sideeffectexecution.FieldStatus)
	}
	if m.attempt != nil {
		fields = append(fields, sideeffectexecution.FieldAttempt)
	}
	if m.output != nil {
		fields = append(fields, sideeffectexecution.FieldOutput)
	}
	if m.started_at != nil {
		fields = append(fields, sideeffectexecution.FieldStartedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sideeffectexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SideEffectExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sideeffectexecution.FieldRunID:
		return m.RunID()
	case sideeffectexecution.FieldStatus:
		return m.Status()
	case sideeffectexecution.FieldAttempt:
		return m.Attempt()
	case sideeffectexecution.FieldOutput:
		return m.Output()
	case sideeffectexecution.FieldStartedAt:
		return m.StartedAt()
	case sideeffectexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SideEffectExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sideeffectexecution.FieldRunID:
		return m.OldRunID(ctx)
	case sideeffectexecution.FieldStatus:
		return m.OldStatus(ctx)
	case sideeffectexecution.FieldAttempt:
		return m.OldAttempt(ctx)
	case sideeffectexecution.FieldOutput:
		return m.OldOutput(ctx)
	case sideeffectexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case sideeffectexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sideeffectexecution.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case sideeffectexecution.FieldStatus:
		v, ok := value.(sideeffectexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sideeffectexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempt(v)
		return nil
	case sideeffectexecution.FieldOutput:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case sideeffectexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case sideeffectexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SideEffectExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addattempt != nil {
		fields = append(fields, sideeffectexecution.FieldAttempt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SideEffectExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sideeffectexecution.FieldAttempt:
		return m.AddedAttempt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SideEffectExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sideeffectexecution.FieldAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SideEffectExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sideeffectexecution.FieldOutput) {
		fields = append(fields, sideeffectexecution.FieldOutput)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SideEffectExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SideEffectExecutionMutation) ClearField(name string) error {
	switch name {
	case sideeffectexecution.FieldOutput:
		m.ClearOutput()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SideEffectExecutionMutation) ResetField(name string) error {
	switch name {
	case sideeffectexecution.FieldRunID:
		m.ResetRunID()
		return nil
	case sideeffectexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case sideeffectexecution.FieldAttempt:
		m.ResetAttempt()
		return nil
	case sideeffectexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case sideeffectexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case sideeffectexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SideEffectExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.side_effect != nil {
		edges = append(edges, sideeffectexecution.EdgeSideEffect)
	}
	if m.activity_execution != nil {
		edges = append(edges, sideeffectexecution.EdgeActivityExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SideEffectExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		if id := m.side_effect; id != nil {
			return []ent.Value{*id}
		}
	case sideeffectexecution.EdgeActivityExecution:
		if id := m.activity_execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SideEffectExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SideEffectExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SideEffectExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedside_effect {
		edges = append(edges, sideeffectexecution.EdgeSideEffect)
	}
	if m.clearedactivity_execution {
		edges = append(edges, sideeffectexecution.EdgeActivityExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SideEffectExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		return m.clearedside_effect
	case sideeffectexecution.EdgeActivityExecution:
		return m.clearedactivity_execution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SideEffectExecutionMutation) ClearEdge(name string) error {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		m.ClearSideEffect()
		return nil
	case sideeffectexecution.EdgeActivityExecution:
		m.ClearActivityExecution()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SideEffectExecutionMutation) ResetEdge(name string) error {
	switch name {
	case sideeffectexecution.EdgeSideEffect:
		m.ResetSideEffect()
		return nil
	case sideeffectexecution.EdgeActivityExecution:
		m.ResetActivityExecution()
		return nil
	}
	return fmt.Errorf("unknown SideEffectExecution edge %s", name)
}

// SignalMutation represents an operation that mutates the Signal nodes in the graph.
type SignalMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	name                      *string
	data                      *[]interface{}
	appenddata                []interface{}
	status                    *signal.Status
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	workflow_execution        *string
	clearedworkflow_execution bool
	done                      bool
	oldValue                  func(context.Context) (*Signal, error)
	predicates                []predicate.Signal
}

var _ ent.Mutation = (*SignalMutation)(nil)

// signalOption allows management of the mutation configuration using functional options.
type signalOption func(*SignalMutation)

// newSignalMutation creates new mutation for the Signal entity.
func newSignalMutation(c config, op Op, opts ...signalOption) *SignalMutation {
	m := &SignalMutation{
		config:        c,
		op:            op,
		typ:           TypeSignal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSignalID sets the ID field of the mutation.
func withSignalID(id string) signalOption {
	return func(m *SignalMutation) {
		var (
			err   error
			once  sync.Once
			value *Signal
		)
		m.oldValue = func(ctx context.Context) (*Signal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Signal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSignal sets the old Signal of the mutation.
func withSignal(node *Signal) signalOption {
	return func(m *SignalMutation) {
		m.oldValue = func(context.Context) (*Signal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SignalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SignalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Signal entities.
func (m *SignalMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SignalMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SignalMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Signal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SignalMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SignalMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Signal entity.
// If the Signal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SignalMutation) ResetName() {
	m.name = nil
}

// SetData sets the "data" field.
func (m *SignalMutation) SetData(i []interface{}) {
	m.data = &i
	m.appenddata = nil
}

// Data returns the value of the "data" field in the mutation.
func (m *SignalMutation) Data() (r []interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Signal entity.
// If the Signal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalMutation) OldData(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// AppendData adds i to the "data" field.
func (m *SignalMutation) AppendData(i []interface{}) {
	m.appenddata = append(m.appenddata, i...)
}

// AppendedData returns the list of values that were appended to the "data" field in this mutation.
func (m *SignalMutation) AppendedData() ([]interface{}, bool) {
	if len(m.appenddata) == 0 {
		return nil, false
	}
	return m.appenddata, true
}

// ClearData clears the value of the "data" field.
func (m *SignalMutation) ClearData() {
	m.data = nil
	m.appenddata = nil
	m.clearedFields[signal.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *SignalMutation) DataCleared() bool {
	_, ok := m.clearedFields[signal.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *SignalMutation) ResetData() {
	m.data = nil
	m.appenddata = nil
	delete(m.clearedFields, signal.FieldData)
}

// SetStatus sets the "status" field.
func (m *SignalMutation) SetStatus(s signal.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SignalMutation) Status() (r signal.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Signal entity.
// If the Signal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalMutation) OldStatus(ctx context.Context) (v signal.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SignalMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SignalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SignalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Signal entity.
// If the Signal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SignalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SignalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SignalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Signal entity.
// If the Signal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SignalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowExecutionID sets the "workflow_execution" edge to the WorkflowExecution entity by id.
func (m *SignalMutation) SetWorkflowExecutionID(id string) {
	m.workflow_execution = &id
}

// ClearWorkflowExecution clears the "workflow_execution" edge to the WorkflowExecution entity.
func (m *SignalMutation) ClearWorkflowExecution() {
	m.clearedworkflow_execution = true
}

// WorkflowExecutionCleared reports if the "workflow_execution" edge to the WorkflowExecution entity was cleared.
func (m *SignalMutation) WorkflowExecutionCleared() bool {
	return m.clearedworkflow_execution
}

// WorkflowExecutionID returns the "workflow_execution" edge ID in the mutation.
func (m *SignalMutation) WorkflowExecutionID() (id string, exists bool) {
	if m.workflow_execution != nil {
		return *m.workflow_execution, true
	}
	return
}

// WorkflowExecutionIDs returns the "workflow_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowExecutionID instead. It exists only for internal usage by the builders.
func (m *SignalMutation) WorkflowExecutionIDs() (ids []string) {
	if id := m.workflow_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowExecution resets all changes to the "workflow_execution" edge.
func (m *SignalMutation) ResetWorkflowExecution() {
	m.workflow_execution = nil
	m.clearedworkflow_execution = false
}

// Where appends a list predicates to the SignalMutation builder.
func (m *SignalMutation) Where(ps ...predicate.Signal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SignalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SignalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Signal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SignalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SignalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Signal).
func (m *SignalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SignalMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, signal.FieldName)
	}
	if m.data != nil {
		fields = append(fields, signal.FieldData)
	}
	if m.status != nil {
		fields = append(fields, signal.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, signal.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, signal.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SignalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signal.FieldName:
		return m.Name()
	case signal.FieldData:
		return m.Data()
	case signal.FieldStatus:
		return m.Status()
	case signal.FieldCreatedAt:
		return m.CreatedAt()
	case signal.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SignalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signal.FieldName:
		return m.OldName(ctx)
	case signal.FieldData:
		return m.OldData(ctx)
	case signal.FieldStatus:
		return m.OldStatus(ctx)
	case signal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case signal.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Signal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signal.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case signal.FieldData:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case signal.FieldStatus:
		v, ok := value.(signal.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case signal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case signal.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Signal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SignalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SignalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Signal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SignalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(signal.FieldData) {
		fields = append(fields, signal.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SignalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SignalMutation) ClearField(name string) error {
	switch name {
	case signal.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown Signal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SignalMutation) ResetField(name string) error {
	switch name {
	case signal.FieldName:
		m.ResetName()
		return nil
	case signal.FieldData:
		m.ResetData()
		return nil
	case signal.FieldStatus:
		m.ResetStatus()
		return nil
	case signal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case signal.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Signal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SignalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflow_execution != nil {
		edges = append(edges, signal.EdgeWorkflowExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SignalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case signal.EdgeWorkflowExecution:
		if id := m.workflow_execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SignalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SignalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SignalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflow_execution {
		edges = append(edges, signal.EdgeWorkflowExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SignalMutation) EdgeCleared(name string) bool {
	switch name {
	case signal.EdgeWorkflowExecution:
		return m.clearedworkflow_execution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SignalMutation) ClearEdge(name string) error {
	switch name {
	case signal.EdgeWorkflowExecution:
		m.ClearWorkflowExecution()
		return nil
	}
	return fmt.Errorf("unknown Signal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SignalMutation) ResetEdge(name string) error {
	switch name {
	case signal.EdgeWorkflowExecution:
		m.ResetWorkflowExecution()
		return nil
	}
	return fmt.Errorf("unknown Signal edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op                Op
	typ               string
	id                *string
	identity          *string
	handler_name      *string
	input             *[]interface{}
	appendinput       []interface{}
	retry_policy      *schema.RetryPolicy
	timeout           *time.Time
	created_at        *time.Time
	clearedFields     map[string]struct{}
	executions        map[string]struct{}
	removedexecutions map[string]struct{}
	clearedexecutions bool
	activities        map[string]struct{}
	removedactivities map[string]struct{}
	clearedactivities bool
	done              bool
	oldValue          func(context.Context) (*Workflow, error)
	predicates        []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id string) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workflow entities.
func (m *WorkflowMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIdentity sets the "identity" field.
func (m *WorkflowMutation) SetIdentity(s string) {
	m.identity = &s
}

// Identity returns the value of the "identity" field in the mutation.
func (m *WorkflowMutation) Identity() (r string, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old "identity" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// ResetIdentity resets all changes to the "identity" field.
func (m *WorkflowMutation) ResetIdentity() {
	m.identity = nil
}

// SetHandlerName sets the "handler_name" field.
func (m *WorkflowMutation) SetHandlerName(s string) {
	m.handler_name = &s
}

// HandlerName returns the value of the "handler_name" field in the mutation.
func (m *WorkflowMutation) HandlerName() (r string, exists bool) {
	v := m.handler_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerName returns the old "handler_name" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldHandlerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerName: %w", err)
	}
	return oldValue.HandlerName, nil
}

// ResetHandlerName resets all changes to the "handler_name" field.
func (m *WorkflowMutation) ResetHandlerName() {
	m.handler_name = nil
}

// SetInput sets the "input" field.
func (m *WorkflowMutation) SetInput(i []interface{}) {
	m.input = &i
	m.appendinput = nil
}

// Input returns the value of the "input" field in the mutation.
func (m *WorkflowMutation) Input() (r []interface{}, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldInput(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// AppendInput adds i to the "input" field.
func (m *WorkflowMutation) AppendInput(i []interface{}) {
	m.appendinput = append(m.appendinput, i...)
}

// AppendedInput returns the list of values that were appended to the "input" field in this mutation.
func (m *WorkflowMutation) AppendedInput() ([]interface{}, bool) {
	if len(m.appendinput) == 0 {
		return nil, false
	}
	return m.appendinput, true
}

// ResetInput resets all changes to the "input" field.
func (m *WorkflowMutation) ResetInput() {
	m.input = nil
	m.appendinput = nil
}

// SetRetryPolicy sets the "retry_policy" field.
func (m *WorkflowMutation) SetRetryPolicy(sp schema.RetryPolicy) {
	m.retry_policy = &sp
}

// RetryPolicy returns the value of the "retry_policy" field in the mutation.
func (m *WorkflowMutation) RetryPolicy() (r schema.RetryPolicy, exists bool) {
	v := m.retry_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryPolicy returns the old "retry_policy" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldRetryPolicy(ctx context.Context) (v schema.RetryPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryPolicy: %w", err)
	}
	return oldValue.RetryPolicy, nil
}

// ClearRetryPolicy clears the value of the "retry_policy" field.
func (m *WorkflowMutation) ClearRetryPolicy() {
	m.retry_policy = nil
	m.clearedFields[workflow.FieldRetryPolicy] = struct{}{}
}

// RetryPolicyCleared returns if the "retry_policy" field was cleared in this mutation.
func (m *WorkflowMutation) RetryPolicyCleared() bool {
	_, ok := m.clearedFields[workflow.FieldRetryPolicy]
	return ok
}

// ResetRetryPolicy resets all changes to the "retry_policy" field.
func (m *WorkflowMutation) ResetRetryPolicy() {
	m.retry_policy = nil
	delete(m.clearedFields, workflow.FieldRetryPolicy)
}

// SetTimeout sets the "timeout" field.
func (m *WorkflowMutation) SetTimeout(t time.Time) {
	m.timeout = &t
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *WorkflowMutation) Timeout() (r time.Time, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldTimeout(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ClearTimeout clears the value of the "timeout" field.
func (m *WorkflowMutation) ClearTimeout() {
	m.timeout = nil
	m.clearedFields[workflow.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *WorkflowMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[workflow.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *WorkflowMutation) ResetTimeout() {
	m.timeout = nil
	delete(m.clearedFields, workflow.FieldTimeout)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddExecutionIDs adds the "executions" edge to the WorkflowExecution entity by ids.
func (m *WorkflowMutation) AddExecutionIDs(ids ...string) {
	if m.executions == nil {
		m.executions = make(map[string]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the WorkflowExecution entity.
func (m *WorkflowMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the WorkflowExecution entity was cleared.
func (m *WorkflowMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the WorkflowExecution entity by IDs.
func (m *WorkflowMutation) RemoveExecutionIDs(ids ...string) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the WorkflowExecution entity.
func (m *WorkflowMutation) RemovedExecutionsIDs() (ids []string) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *WorkflowMutation) ExecutionsIDs() (ids []string) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *WorkflowMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// AddActivityIDs adds the "activities" edge to the Activity entity by ids.
func (m *WorkflowMutation) AddActivityIDs(ids ...string) {
	if m.activities == nil {
		m.activities = make(map[string]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the Activity entity.
func (m *WorkflowMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the Activity entity was cleared.
func (m *WorkflowMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the Activity entity by IDs.
func (m *WorkflowMutation) RemoveActivityIDs(ids ...string) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the Activity entity.
func (m *WorkflowMutation) RemovedActivitiesIDs() (ids []string) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *WorkflowMutation) ActivitiesIDs() (ids []string) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *WorkflowMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workflow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.identity != nil {
		fields = append(fields, workflow.FieldIdentity)
	}
	if m.handler_name != nil {
		fields = append(fields, workflow.FieldHandlerName)
	}
	if m.input != nil {
		fields = append(fields, workflow.FieldInput)
	}
	if m.retry_policy != nil {
		fields = append(fields, workflow.FieldRetryPolicy)
	}
	if m.timeout != nil {
		fields = append(fields, workflow.FieldTimeout)
	}
	if m.created_at != nil {
		fields = append(fields, workflow.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldIdentity:
		return m.Identity()
	case workflow.FieldHandlerName:
		return m.HandlerName()
	case workflow.FieldInput:
		return m.Input()
	case workflow.FieldRetryPolicy:
		return m.RetryPolicy()
	case workflow.FieldTimeout:
		return m.Timeout()
	case workflow.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldIdentity:
		return m.OldIdentity(ctx)
	case workflow.FieldHandlerName:
		return m.OldHandlerName(ctx)
	case workflow.FieldInput:
		return m.OldInput(ctx)
	case workflow.FieldRetryPolicy:
		return m.OldRetryPolicy(ctx)
	case workflow.FieldTimeout:
		return m.OldTimeout(ctx)
	case workflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	case workflow.FieldHandlerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerName(v)
		return nil
	case workflow.FieldInput:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case workflow.FieldRetryPolicy:
		v, ok := value.(schema.RetryPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryPolicy(v)
		return nil
	case workflow.FieldTimeout:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case workflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldRetryPolicy) {
		fields = append(fields, workflow.FieldRetryPolicy)
	}
	if m.FieldCleared(workflow.FieldTimeout) {
		fields = append(fields, workflow.FieldTimeout)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldRetryPolicy:
		m.ClearRetryPolicy()
		return nil
	case workflow.FieldTimeout:
		m.ClearTimeout()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldIdentity:
		m.ResetIdentity()
		return nil
	case workflow.FieldHandlerName:
		m.ResetHandlerName()
		return nil
	case workflow.FieldInput:
		m.ResetInput()
		return nil
	case workflow.FieldRetryPolicy:
		m.ResetRetryPolicy()
		return nil
	case workflow.FieldTimeout:
		m.ResetTimeout()
		return nil
	case workflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.executions != nil {
		edges = append(edges, workflow.EdgeExecutions)
	}
	if m.activities != nil {
		edges = append(edges, workflow.EdgeActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedexecutions != nil {
		edges = append(edges, workflow.EdgeExecutions)
	}
	if m.removedactivities != nil {
		edges = append(edges, workflow.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexecutions {
		edges = append(edges, workflow.EdgeExecutions)
	}
	if m.clearedactivities {
		edges = append(edges, workflow.EdgeActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case workflow.EdgeExecutions:
		return m.clearedexecutions
	case workflow.EdgeActivities:
		return m.clearedactivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	switch name {
	case workflow.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case workflow.EdgeActivities:
		m.ResetActivities()
		return nil
	}
	return fmt.Errorf("unknown Workflow edge %s", name)
}

// WorkflowExecutionMutation represents an operation that mutates the WorkflowExecution nodes in the graph.
type WorkflowExecutionMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	run_id                     *string
	status                     *workflowexecution.Status
	output                     *[]interface{}
	appendoutput               []interface{}
	error                      *string
	started_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	workflow                   *string
	clearedworkflow            bool
	activity_executions        map[string]struct{}
	removedactivity_executions map[string]struct{}
	clearedactivity_executions bool
	signals                    map[string]struct{}
	removedsignals             map[string]struct{}
	clearedsignals             bool
	done                       bool
	oldValue                   func(context.Context) (*WorkflowExecution, error)
	predicates                 []predicate.WorkflowExecution
}

var _ ent.Mutation = (*WorkflowExecutionMutation)(nil)

// workflowexecutionOption allows management of the mutation configuration using functional options.
type workflowexecutionOption func(*WorkflowExecutionMutation)

// newWorkflowExecutionMutation creates new mutation for the WorkflowExecution entity.
func newWorkflowExecutionMutation(c config, op Op, opts ...workflowexecutionOption) *WorkflowExecutionMutation {
	m := &WorkflowExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowExecutionID sets the ID field of the mutation.
func withWorkflowExecutionID(id string) workflowexecutionOption {
	return func(m *WorkflowExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowExecution
		)
		m.oldValue = func(ctx context.Context) (*WorkflowExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowExecution sets the old WorkflowExecution of the mutation.
func withWorkflowExecution(node *WorkflowExecution) workflowexecutionOption {
	return func(m *WorkflowExecutionMutation) {
		m.oldValue = func(context.Context) (*WorkflowExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowExecution entities.
func (m *WorkflowExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *WorkflowExecutionMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *WorkflowExecutionMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ResetRunID resets all changes to the "run_id" field.
func (m *WorkflowExecutionMutation) ResetRunID() {
	m.run_id = nil
}

// SetStatus sets the "status" field.
func (m *WorkflowExecutionMutation) SetStatus(w workflowexecution.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowExecutionMutation) Status() (r workflowexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStatus(ctx context.Context) (v workflowexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetOutput sets the "output" field.
func (m *WorkflowExecutionMutation) SetOutput(i []interface{}) {
	m.output = &i
	m.appendoutput = nil
}

// Output returns the value of the "output" field in the mutation.
func (m *WorkflowExecutionMutation) Output() (r []interface{}, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldOutput(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// AppendOutput adds i to the "output" field.
func (m *WorkflowExecutionMutation) AppendOutput(i []interface{}) {
	m.appendoutput = append(m.appendoutput, i...)
}

// AppendedOutput returns the list of values that were appended to the "output" field in this mutation.
func (m *WorkflowExecutionMutation) AppendedOutput() ([]interface{}, bool) {
	if len(m.appendoutput) == 0 {
		return nil, false
	}
	return m.appendoutput, true
}

// ClearOutput clears the value of the "output" field.
func (m *WorkflowExecutionMutation) ClearOutput() {
	m.output = nil
	m.appendoutput = nil
	m.clearedFields[workflowexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *WorkflowExecutionMutation) ResetOutput() {
	m.output = nil
	m.appendoutput = nil
	delete(m.clearedFields, workflowexecution.FieldOutput)
}

// SetError sets the "error" field.
func (m *WorkflowExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *WorkflowExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *WorkflowExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[workflowexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *WorkflowExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, workflowexecution.FieldError)
}

// SetStartedAt sets the "started_at" field.
func (m *WorkflowExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *WorkflowExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *WorkflowExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *WorkflowExecutionMutation) SetWorkflowID(id string) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *WorkflowExecutionMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *WorkflowExecutionMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *WorkflowExecutionMutation) WorkflowID() (id string, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowExecutionMutation) WorkflowIDs() (ids []string) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowExecutionMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// AddActivityExecutionIDs adds the "activity_executions" edge to the ActivityExecution entity by ids.
func (m *WorkflowExecutionMutation) AddActivityExecutionIDs(ids ...string) {
	if m.activity_executions == nil {
		m.activity_executions = make(map[string]struct{})
	}
	for i := range ids {
		m.activity_executions[ids[i]] = struct{}{}
	}
}

// ClearActivityExecutions clears the "activity_executions" edge to the ActivityExecution entity.
func (m *WorkflowExecutionMutation) ClearActivityExecutions() {
	m.clearedactivity_executions = true
}

// ActivityExecutionsCleared reports if the "activity_executions" edge to the ActivityExecution entity was cleared.
func (m *WorkflowExecutionMutation) ActivityExecutionsCleared() bool {
	return m.clearedactivity_executions
}

// RemoveActivityExecutionIDs removes the "activity_executions" edge to the ActivityExecution entity by IDs.
func (m *WorkflowExecutionMutation) RemoveActivityExecutionIDs(ids ...string) {
	if m.removedactivity_executions == nil {
		m.removedactivity_executions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activity_executions, ids[i])
		m.removedactivity_executions[ids[i]] = struct{}{}
	}
}

// RemovedActivityExecutions returns the removed IDs of the "activity_executions" edge to the ActivityExecution entity.
func (m *WorkflowExecutionMutation) RemovedActivityExecutionsIDs() (ids []string) {
	for id := range m.removedactivity_executions {
		ids = append(ids, id)
	}
	return
}

// ActivityExecutionsIDs returns the "activity_executions" edge IDs in the mutation.
func (m *WorkflowExecutionMutation) ActivityExecutionsIDs() (ids []string) {
	for id := range m.activity_executions {
		ids = append(ids, id)
	}
	return
}

// ResetActivityExecutions resets all changes to the "activity_executions" edge.
func (m *WorkflowExecutionMutation) ResetActivityExecutions() {
	m.activity_executions = nil
	m.clearedactivity_executions = false
	m.removedactivity_executions = nil
}

// AddSignalIDs adds the "signals" edge to the Signal entity by ids.
func (m *WorkflowExecutionMutation) AddSignalIDs(ids ...string) {
	if m.signals == nil {
		m.signals = make(map[string]struct{})
	}
	for i := range ids {
		m.signals[ids[i]] = struct{}{}
	}
}

// ClearSignals clears the "signals" edge to the Signal entity.
func (m *WorkflowExecutionMutation) ClearSignals() {
	m.clearedsignals = true
}

// SignalsCleared reports if the "signals" edge to the Signal entity was cleared.
func (m *WorkflowExecutionMutation) SignalsCleared() bool {
	return m.clearedsignals
}

// RemoveSignalIDs removes the "signals" edge to the Signal entity by IDs.
func (m *WorkflowExecutionMutation) RemoveSignalIDs(ids ...string) {
	if m.removedsignals == nil {
		m.removedsignals = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.signals, ids[i])
		m.removedsignals[ids[i]] = struct{}{}
	}
}

// RemovedSignals returns the removed IDs of the "signals" edge to the Signal entity.
func (m *WorkflowExecutionMutation) RemovedSignalsIDs() (ids []string) {
	for id := range m.removedsignals {
		ids = append(ids, id)
	}
	return
}

// SignalsIDs returns the "signals" edge IDs in the mutation.
func (m *WorkflowExecutionMutation) SignalsIDs() (ids []string) {
	for id := range m.signals {
		ids = append(ids, id)
	}
	return
}

// ResetSignals resets all changes to the "signals" edge.
func (m *WorkflowExecutionMutation) ResetSignals() {
	m.signals = nil
	m.clearedsignals = false
	m.removedsignals = nil
}

// Where appends a list predicates to the WorkflowExecutionMutation builder.
func (m *WorkflowExecutionMutation) Where(ps ...predicate.WorkflowExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowExecution).
func (m *WorkflowExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowExecutionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.run_id != nil {
		fields = append(fields, workflowexecution.FieldRunID)
	}
	if m.status != nil {
		fields = append(fields, workflowexecution.FieldStatus)
	}
	if m.output != nil {
		fields = append(fields, workflowexecution.FieldOutput)
	}
	if m.error != nil {
		fields = append(fields, workflowexecution.FieldError)
	}
	if m.started_at != nil {
		fields = append(fields, workflowexecution.FieldStartedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowexecution.FieldRunID:
		return m.RunID()
	case workflowexecution.FieldStatus:
		return m.Status()
	case workflowexecution.FieldOutput:
		return m.Output()
	case workflowexecution.FieldError:
		return m.Error()
	case workflowexecution.FieldStartedAt:
		return m.StartedAt()
	case workflowexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowexecution.FieldRunID:
		return m.OldRunID(ctx)
	case workflowexecution.FieldStatus:
		return m.OldStatus(ctx)
	case workflowexecution.FieldOutput:
		return m.OldOutput(ctx)
	case workflowexecution.FieldError:
		return m.OldError(ctx)
	case workflowexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case workflowexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowexecution.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case workflowexecution.FieldStatus:
		v, ok := value.(workflowexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowexecution.FieldOutput:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case workflowexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case workflowexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case workflowexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowExecutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowExecutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowexecution.FieldOutput) {
		fields = append(fields, workflowexecution.FieldOutput)
	}
	if m.FieldCleared(workflowexecution.FieldError) {
		fields = append(fields, workflowexecution.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearField(name string) error {
	switch name {
	case workflowexecution.FieldOutput:
		m.ClearOutput()
		return nil
	case workflowexecution.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetField(name string) error {
	switch name {
	case workflowexecution.FieldRunID:
		m.ResetRunID()
		return nil
	case workflowexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case workflowexecution.FieldError:
		m.ResetError()
		return nil
	case workflowexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case workflowexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workflow != nil {
		edges = append(edges, workflowexecution.EdgeWorkflow)
	}
	if m.activity_executions != nil {
		edges = append(edges, workflowexecution.EdgeActivityExecutions)
	}
	if m.signals != nil {
		edges = append(edges, workflowexecution.EdgeSignals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowexecution.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case workflowexecution.EdgeActivityExecutions:
		ids := make([]ent.Value, 0, len(m.activity_executions))
		for id := range m.activity_executions {
			ids = append(ids, id)
		}
		return ids
	case workflowexecution.EdgeSignals:
		ids := make([]ent.Value, 0, len(m.signals))
		for id := range m.signals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedactivity_executions != nil {
		edges = append(edges, workflowexecution.EdgeActivityExecutions)
	}
	if m.removedsignals != nil {
		edges = append(edges, workflowexecution.EdgeSignals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowExecutionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflowexecution.EdgeActivityExecutions:
		ids := make([]ent.Value, 0, len(m.removedactivity_executions))
		for id := range m.removedactivity_executions {
			ids = append(ids, id)
		}
		return ids
	case workflowexecution.EdgeSignals:
		ids := make([]ent.Value, 0, len(m.removedsignals))
		for id := range m.removedsignals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkflow {
		edges = append(edges, workflowexecution.EdgeWorkflow)
	}
	if m.clearedactivity_executions {
		edges = append(edges, workflowexecution.EdgeActivityExecutions)
	}
	if m.clearedsignals {
		edges = append(edges, workflowexecution.EdgeSignals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowexecution.EdgeWorkflow:
		return m.clearedworkflow
	case workflowexecution.EdgeActivityExecutions:
		return m.clearedactivity_executions
	case workflowexecution.EdgeSignals:
		return m.clearedsignals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearEdge(name string) error {
	switch name {
	case workflowexecution.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetEdge(name string) error {
	switch name {
	case workflowexecution.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case workflowexecution.EdgeActivityExecutions:
		m.ResetActivityExecutions()
		return nil
	case workflowexecution.EdgeSignals:
		m.ResetSignals()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution edge %s", name)
}
