// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/davidroman0O/go-tempolite/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/davidroman0O/go-tempolite/ent/executioncontext"
	"github.com/davidroman0O/go-tempolite/ent/executionunit"
	"github.com/davidroman0O/go-tempolite/ent/sagacompensation"
	"github.com/davidroman0O/go-tempolite/ent/sagatransaction"
	"github.com/davidroman0O/go-tempolite/ent/task"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ExecutionContext is the client for interacting with the ExecutionContext builders.
	ExecutionContext *ExecutionContextClient
	// ExecutionUnit is the client for interacting with the ExecutionUnit builders.
	ExecutionUnit *ExecutionUnitClient
	// SagaCompensation is the client for interacting with the SagaCompensation builders.
	SagaCompensation *SagaCompensationClient
	// SagaTransaction is the client for interacting with the SagaTransaction builders.
	SagaTransaction *SagaTransactionClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ExecutionContext = NewExecutionContextClient(c.config)
	c.ExecutionUnit = NewExecutionUnitClient(c.config)
	c.SagaCompensation = NewSagaCompensationClient(c.config)
	c.SagaTransaction = NewSagaTransactionClient(c.config)
	c.Task = NewTaskClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		ExecutionContext: NewExecutionContextClient(cfg),
		ExecutionUnit:    NewExecutionUnitClient(cfg),
		SagaCompensation: NewSagaCompensationClient(cfg),
		SagaTransaction:  NewSagaTransactionClient(cfg),
		Task:             NewTaskClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		ExecutionContext: NewExecutionContextClient(cfg),
		ExecutionUnit:    NewExecutionUnitClient(cfg),
		SagaCompensation: NewSagaCompensationClient(cfg),
		SagaTransaction:  NewSagaTransactionClient(cfg),
		Task:             NewTaskClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ExecutionContext.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.ExecutionContext.Use(hooks...)
	c.ExecutionUnit.Use(hooks...)
	c.SagaCompensation.Use(hooks...)
	c.SagaTransaction.Use(hooks...)
	c.Task.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.ExecutionContext.Intercept(interceptors...)
	c.ExecutionUnit.Intercept(interceptors...)
	c.SagaCompensation.Intercept(interceptors...)
	c.SagaTransaction.Intercept(interceptors...)
	c.Task.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ExecutionContextMutation:
		return c.ExecutionContext.mutate(ctx, m)
	case *ExecutionUnitMutation:
		return c.ExecutionUnit.mutate(ctx, m)
	case *SagaCompensationMutation:
		return c.SagaCompensation.mutate(ctx, m)
	case *SagaTransactionMutation:
		return c.SagaTransaction.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ExecutionContextClient is a client for the ExecutionContext schema.
type ExecutionContextClient struct {
	config
}

// NewExecutionContextClient returns a client for the ExecutionContext from the given config.
func NewExecutionContextClient(c config) *ExecutionContextClient {
	return &ExecutionContextClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `executioncontext.Hooks(f(g(h())))`.
func (c *ExecutionContextClient) Use(hooks ...Hook) {
	c.hooks.ExecutionContext = append(c.hooks.ExecutionContext, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `executioncontext.Intercept(f(g(h())))`.
func (c *ExecutionContextClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExecutionContext = append(c.inters.ExecutionContext, interceptors...)
}

// Create returns a builder for creating a ExecutionContext entity.
func (c *ExecutionContextClient) Create() *ExecutionContextCreate {
	mutation := newExecutionContextMutation(c.config, OpCreate)
	return &ExecutionContextCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExecutionContext entities.
func (c *ExecutionContextClient) CreateBulk(builders ...*ExecutionContextCreate) *ExecutionContextCreateBulk {
	return &ExecutionContextCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExecutionContextClient) MapCreateBulk(slice any, setFunc func(*ExecutionContextCreate, int)) *ExecutionContextCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExecutionContextCreateBulk{err: fmt.Errorf("calling to ExecutionContextClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExecutionContextCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExecutionContextCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExecutionContext.
func (c *ExecutionContextClient) Update() *ExecutionContextUpdate {
	mutation := newExecutionContextMutation(c.config, OpUpdate)
	return &ExecutionContextUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExecutionContextClient) UpdateOne(ec *ExecutionContext) *ExecutionContextUpdateOne {
	mutation := newExecutionContextMutation(c.config, OpUpdateOne, withExecutionContext(ec))
	return &ExecutionContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExecutionContextClient) UpdateOneID(id string) *ExecutionContextUpdateOne {
	mutation := newExecutionContextMutation(c.config, OpUpdateOne, withExecutionContextID(id))
	return &ExecutionContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExecutionContext.
func (c *ExecutionContextClient) Delete() *ExecutionContextDelete {
	mutation := newExecutionContextMutation(c.config, OpDelete)
	return &ExecutionContextDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExecutionContextClient) DeleteOne(ec *ExecutionContext) *ExecutionContextDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExecutionContextClient) DeleteOneID(id string) *ExecutionContextDeleteOne {
	builder := c.Delete().Where(executioncontext.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExecutionContextDeleteOne{builder}
}

// Query returns a query builder for ExecutionContext.
func (c *ExecutionContextClient) Query() *ExecutionContextQuery {
	return &ExecutionContextQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExecutionContext},
		inters: c.Interceptors(),
	}
}

// Get returns a ExecutionContext entity by its id.
func (c *ExecutionContextClient) Get(ctx context.Context, id string) (*ExecutionContext, error) {
	return c.Query().Where(executioncontext.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExecutionContextClient) GetX(ctx context.Context, id string) *ExecutionContext {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecutionUnits queries the execution_units edge of a ExecutionContext.
func (c *ExecutionContextClient) QueryExecutionUnits(ec *ExecutionContext) *ExecutionUnitQuery {
	query := (&ExecutionUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(executioncontext.Table, executioncontext.FieldID, id),
			sqlgraph.To(executionunit.Table, executionunit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, executioncontext.ExecutionUnitsTable, executioncontext.ExecutionUnitsColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExecutionContextClient) Hooks() []Hook {
	return c.hooks.ExecutionContext
}

// Interceptors returns the client interceptors.
func (c *ExecutionContextClient) Interceptors() []Interceptor {
	return c.inters.ExecutionContext
}

func (c *ExecutionContextClient) mutate(ctx context.Context, m *ExecutionContextMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExecutionContextCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExecutionContextUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExecutionContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExecutionContextDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExecutionContext mutation op: %q", m.Op())
	}
}

// ExecutionUnitClient is a client for the ExecutionUnit schema.
type ExecutionUnitClient struct {
	config
}

// NewExecutionUnitClient returns a client for the ExecutionUnit from the given config.
func NewExecutionUnitClient(c config) *ExecutionUnitClient {
	return &ExecutionUnitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `executionunit.Hooks(f(g(h())))`.
func (c *ExecutionUnitClient) Use(hooks ...Hook) {
	c.hooks.ExecutionUnit = append(c.hooks.ExecutionUnit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `executionunit.Intercept(f(g(h())))`.
func (c *ExecutionUnitClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExecutionUnit = append(c.inters.ExecutionUnit, interceptors...)
}

// Create returns a builder for creating a ExecutionUnit entity.
func (c *ExecutionUnitClient) Create() *ExecutionUnitCreate {
	mutation := newExecutionUnitMutation(c.config, OpCreate)
	return &ExecutionUnitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExecutionUnit entities.
func (c *ExecutionUnitClient) CreateBulk(builders ...*ExecutionUnitCreate) *ExecutionUnitCreateBulk {
	return &ExecutionUnitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExecutionUnitClient) MapCreateBulk(slice any, setFunc func(*ExecutionUnitCreate, int)) *ExecutionUnitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExecutionUnitCreateBulk{err: fmt.Errorf("calling to ExecutionUnitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExecutionUnitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExecutionUnitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExecutionUnit.
func (c *ExecutionUnitClient) Update() *ExecutionUnitUpdate {
	mutation := newExecutionUnitMutation(c.config, OpUpdate)
	return &ExecutionUnitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExecutionUnitClient) UpdateOne(eu *ExecutionUnit) *ExecutionUnitUpdateOne {
	mutation := newExecutionUnitMutation(c.config, OpUpdateOne, withExecutionUnit(eu))
	return &ExecutionUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExecutionUnitClient) UpdateOneID(id string) *ExecutionUnitUpdateOne {
	mutation := newExecutionUnitMutation(c.config, OpUpdateOne, withExecutionUnitID(id))
	return &ExecutionUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExecutionUnit.
func (c *ExecutionUnitClient) Delete() *ExecutionUnitDelete {
	mutation := newExecutionUnitMutation(c.config, OpDelete)
	return &ExecutionUnitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExecutionUnitClient) DeleteOne(eu *ExecutionUnit) *ExecutionUnitDeleteOne {
	return c.DeleteOneID(eu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExecutionUnitClient) DeleteOneID(id string) *ExecutionUnitDeleteOne {
	builder := c.Delete().Where(executionunit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExecutionUnitDeleteOne{builder}
}

// Query returns a query builder for ExecutionUnit.
func (c *ExecutionUnitClient) Query() *ExecutionUnitQuery {
	return &ExecutionUnitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExecutionUnit},
		inters: c.Interceptors(),
	}
}

// Get returns a ExecutionUnit entity by its id.
func (c *ExecutionUnitClient) Get(ctx context.Context, id string) (*ExecutionUnit, error) {
	return c.Query().Where(executionunit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExecutionUnitClient) GetX(ctx context.Context, id string) *ExecutionUnit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecutionContext queries the execution_context edge of a ExecutionUnit.
func (c *ExecutionUnitClient) QueryExecutionContext(eu *ExecutionUnit) *ExecutionContextQuery {
	query := (&ExecutionContextClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(executionunit.Table, executionunit.FieldID, id),
			sqlgraph.To(executioncontext.Table, executioncontext.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, executionunit.ExecutionContextTable, executionunit.ExecutionContextColumn),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a ExecutionUnit.
func (c *ExecutionUnitClient) QueryParent(eu *ExecutionUnit) *ExecutionUnitQuery {
	query := (&ExecutionUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(executionunit.Table, executionunit.FieldID, id),
			sqlgraph.To(executionunit.Table, executionunit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, executionunit.ParentTable, executionunit.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a ExecutionUnit.
func (c *ExecutionUnitClient) QueryChildren(eu *ExecutionUnit) *ExecutionUnitQuery {
	query := (&ExecutionUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(executionunit.Table, executionunit.FieldID, id),
			sqlgraph.To(executionunit.Table, executionunit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, executionunit.ChildrenTable, executionunit.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a ExecutionUnit.
func (c *ExecutionUnitClient) QueryTasks(eu *ExecutionUnit) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(executionunit.Table, executionunit.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, executionunit.TasksTable, executionunit.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySagaTransactions queries the saga_transactions edge of a ExecutionUnit.
func (c *ExecutionUnitClient) QuerySagaTransactions(eu *ExecutionUnit) *SagaTransactionQuery {
	query := (&SagaTransactionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(executionunit.Table, executionunit.FieldID, id),
			sqlgraph.To(sagatransaction.Table, sagatransaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, executionunit.SagaTransactionsTable, executionunit.SagaTransactionsColumn),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySagaCompensations queries the saga_compensations edge of a ExecutionUnit.
func (c *ExecutionUnitClient) QuerySagaCompensations(eu *ExecutionUnit) *SagaCompensationQuery {
	query := (&SagaCompensationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(executionunit.Table, executionunit.FieldID, id),
			sqlgraph.To(sagacompensation.Table, sagacompensation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, executionunit.SagaCompensationsTable, executionunit.SagaCompensationsColumn),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExecutionUnitClient) Hooks() []Hook {
	return c.hooks.ExecutionUnit
}

// Interceptors returns the client interceptors.
func (c *ExecutionUnitClient) Interceptors() []Interceptor {
	return c.inters.ExecutionUnit
}

func (c *ExecutionUnitClient) mutate(ctx context.Context, m *ExecutionUnitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExecutionUnitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExecutionUnitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExecutionUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExecutionUnitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExecutionUnit mutation op: %q", m.Op())
	}
}

// SagaCompensationClient is a client for the SagaCompensation schema.
type SagaCompensationClient struct {
	config
}

// NewSagaCompensationClient returns a client for the SagaCompensation from the given config.
func NewSagaCompensationClient(c config) *SagaCompensationClient {
	return &SagaCompensationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sagacompensation.Hooks(f(g(h())))`.
func (c *SagaCompensationClient) Use(hooks ...Hook) {
	c.hooks.SagaCompensation = append(c.hooks.SagaCompensation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sagacompensation.Intercept(f(g(h())))`.
func (c *SagaCompensationClient) Intercept(interceptors ...Interceptor) {
	c.inters.SagaCompensation = append(c.inters.SagaCompensation, interceptors...)
}

// Create returns a builder for creating a SagaCompensation entity.
func (c *SagaCompensationClient) Create() *SagaCompensationCreate {
	mutation := newSagaCompensationMutation(c.config, OpCreate)
	return &SagaCompensationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SagaCompensation entities.
func (c *SagaCompensationClient) CreateBulk(builders ...*SagaCompensationCreate) *SagaCompensationCreateBulk {
	return &SagaCompensationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SagaCompensationClient) MapCreateBulk(slice any, setFunc func(*SagaCompensationCreate, int)) *SagaCompensationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SagaCompensationCreateBulk{err: fmt.Errorf("calling to SagaCompensationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SagaCompensationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SagaCompensationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SagaCompensation.
func (c *SagaCompensationClient) Update() *SagaCompensationUpdate {
	mutation := newSagaCompensationMutation(c.config, OpUpdate)
	return &SagaCompensationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SagaCompensationClient) UpdateOne(sc *SagaCompensation) *SagaCompensationUpdateOne {
	mutation := newSagaCompensationMutation(c.config, OpUpdateOne, withSagaCompensation(sc))
	return &SagaCompensationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SagaCompensationClient) UpdateOneID(id string) *SagaCompensationUpdateOne {
	mutation := newSagaCompensationMutation(c.config, OpUpdateOne, withSagaCompensationID(id))
	return &SagaCompensationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SagaCompensation.
func (c *SagaCompensationClient) Delete() *SagaCompensationDelete {
	mutation := newSagaCompensationMutation(c.config, OpDelete)
	return &SagaCompensationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SagaCompensationClient) DeleteOne(sc *SagaCompensation) *SagaCompensationDeleteOne {
	return c.DeleteOneID(sc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SagaCompensationClient) DeleteOneID(id string) *SagaCompensationDeleteOne {
	builder := c.Delete().Where(sagacompensation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SagaCompensationDeleteOne{builder}
}

// Query returns a query builder for SagaCompensation.
func (c *SagaCompensationClient) Query() *SagaCompensationQuery {
	return &SagaCompensationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSagaCompensation},
		inters: c.Interceptors(),
	}
}

// Get returns a SagaCompensation entity by its id.
func (c *SagaCompensationClient) Get(ctx context.Context, id string) (*SagaCompensation, error) {
	return c.Query().Where(sagacompensation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SagaCompensationClient) GetX(ctx context.Context, id string) *SagaCompensation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecutionUnit queries the execution_unit edge of a SagaCompensation.
func (c *SagaCompensationClient) QueryExecutionUnit(sc *SagaCompensation) *ExecutionUnitQuery {
	query := (&ExecutionUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagacompensation.Table, sagacompensation.FieldID, id),
			sqlgraph.To(executionunit.Table, executionunit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sagacompensation.ExecutionUnitTable, sagacompensation.ExecutionUnitColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTask queries the task edge of a SagaCompensation.
func (c *SagaCompensationClient) QueryTask(sc *SagaCompensation) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagacompensation.Table, sagacompensation.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, sagacompensation.TaskTable, sagacompensation.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransaction queries the transaction edge of a SagaCompensation.
func (c *SagaCompensationClient) QueryTransaction(sc *SagaCompensation) *SagaTransactionQuery {
	query := (&SagaTransactionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagacompensation.Table, sagacompensation.FieldID, id),
			sqlgraph.To(sagatransaction.Table, sagatransaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, sagacompensation.TransactionTable, sagacompensation.TransactionColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SagaCompensationClient) Hooks() []Hook {
	return c.hooks.SagaCompensation
}

// Interceptors returns the client interceptors.
func (c *SagaCompensationClient) Interceptors() []Interceptor {
	return c.inters.SagaCompensation
}

func (c *SagaCompensationClient) mutate(ctx context.Context, m *SagaCompensationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SagaCompensationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SagaCompensationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SagaCompensationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SagaCompensationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SagaCompensation mutation op: %q", m.Op())
	}
}

// SagaTransactionClient is a client for the SagaTransaction schema.
type SagaTransactionClient struct {
	config
}

// NewSagaTransactionClient returns a client for the SagaTransaction from the given config.
func NewSagaTransactionClient(c config) *SagaTransactionClient {
	return &SagaTransactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sagatransaction.Hooks(f(g(h())))`.
func (c *SagaTransactionClient) Use(hooks ...Hook) {
	c.hooks.SagaTransaction = append(c.hooks.SagaTransaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sagatransaction.Intercept(f(g(h())))`.
func (c *SagaTransactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.SagaTransaction = append(c.inters.SagaTransaction, interceptors...)
}

// Create returns a builder for creating a SagaTransaction entity.
func (c *SagaTransactionClient) Create() *SagaTransactionCreate {
	mutation := newSagaTransactionMutation(c.config, OpCreate)
	return &SagaTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SagaTransaction entities.
func (c *SagaTransactionClient) CreateBulk(builders ...*SagaTransactionCreate) *SagaTransactionCreateBulk {
	return &SagaTransactionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SagaTransactionClient) MapCreateBulk(slice any, setFunc func(*SagaTransactionCreate, int)) *SagaTransactionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SagaTransactionCreateBulk{err: fmt.Errorf("calling to SagaTransactionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SagaTransactionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SagaTransactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SagaTransaction.
func (c *SagaTransactionClient) Update() *SagaTransactionUpdate {
	mutation := newSagaTransactionMutation(c.config, OpUpdate)
	return &SagaTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SagaTransactionClient) UpdateOne(st *SagaTransaction) *SagaTransactionUpdateOne {
	mutation := newSagaTransactionMutation(c.config, OpUpdateOne, withSagaTransaction(st))
	return &SagaTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SagaTransactionClient) UpdateOneID(id string) *SagaTransactionUpdateOne {
	mutation := newSagaTransactionMutation(c.config, OpUpdateOne, withSagaTransactionID(id))
	return &SagaTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SagaTransaction.
func (c *SagaTransactionClient) Delete() *SagaTransactionDelete {
	mutation := newSagaTransactionMutation(c.config, OpDelete)
	return &SagaTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SagaTransactionClient) DeleteOne(st *SagaTransaction) *SagaTransactionDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SagaTransactionClient) DeleteOneID(id string) *SagaTransactionDeleteOne {
	builder := c.Delete().Where(sagatransaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SagaTransactionDeleteOne{builder}
}

// Query returns a query builder for SagaTransaction.
func (c *SagaTransactionClient) Query() *SagaTransactionQuery {
	return &SagaTransactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSagaTransaction},
		inters: c.Interceptors(),
	}
}

// Get returns a SagaTransaction entity by its id.
func (c *SagaTransactionClient) Get(ctx context.Context, id string) (*SagaTransaction, error) {
	return c.Query().Where(sagatransaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SagaTransactionClient) GetX(ctx context.Context, id string) *SagaTransaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecutionUnit queries the execution_unit edge of a SagaTransaction.
func (c *SagaTransactionClient) QueryExecutionUnit(st *SagaTransaction) *ExecutionUnitQuery {
	query := (&ExecutionUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagatransaction.Table, sagatransaction.FieldID, id),
			sqlgraph.To(executionunit.Table, executionunit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sagatransaction.ExecutionUnitTable, sagatransaction.ExecutionUnitColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTask queries the task edge of a SagaTransaction.
func (c *SagaTransactionClient) QueryTask(st *SagaTransaction) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagatransaction.Table, sagatransaction.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, sagatransaction.TaskTable, sagatransaction.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompensation queries the compensation edge of a SagaTransaction.
func (c *SagaTransactionClient) QueryCompensation(st *SagaTransaction) *SagaCompensationQuery {
	query := (&SagaCompensationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sagatransaction.Table, sagatransaction.FieldID, id),
			sqlgraph.To(sagacompensation.Table, sagacompensation.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, sagatransaction.CompensationTable, sagatransaction.CompensationColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SagaTransactionClient) Hooks() []Hook {
	return c.hooks.SagaTransaction
}

// Interceptors returns the client interceptors.
func (c *SagaTransactionClient) Interceptors() []Interceptor {
	return c.inters.SagaTransaction
}

func (c *SagaTransactionClient) mutate(ctx context.Context, m *SagaTransactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SagaTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SagaTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SagaTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SagaTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SagaTransaction mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id string) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id string) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id string) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id string) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExecutionUnit queries the execution_unit edge of a Task.
func (c *TaskClient) QueryExecutionUnit(t *Task) *ExecutionUnitQuery {
	query := (&ExecutionUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(executionunit.Table, executionunit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.ExecutionUnitTable, task.ExecutionUnitColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ExecutionContext, ExecutionUnit, SagaCompensation, SagaTransaction,
		Task []ent.Hook
	}
	inters struct {
		ExecutionContext, ExecutionUnit, SagaCompensation, SagaTransaction,
		Task []ent.Interceptor
	}
)
